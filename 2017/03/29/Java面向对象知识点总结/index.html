<!-- build time:Sun Jan 27 2019 18:21:35 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="theme-color" content="#202020"><meta http-equiv="x-ua-compatible" content="ie=edge"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><meta name="keywords" content="Java,面向对象,继承,封装,多态,"><meta name="description" content="Java面向对象之三大特性"><link rel="icon" type="image/x-icon" href="/img/swuixw.png"><title>Java面向对象之三大特性 [ 筱炜的博客 ]</title><link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" href="/css/xoxo.css"></head><body><div class="nav-container"><nav class="home-menu pure-menu pure-menu-horizontal"><a class="pure-menu-heading" href="/"><img class="avatar" src="https://swushxw.github.io/img/swuixw.png"> <span class="title">筱炜的博客</span></a><ul class="pure-menu-list clearfix"><li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li><li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li><li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li></ul></nav></div><div class="container" id="content-outer"><div class="inner" id="content-inner"><div class="post-container"><article class="post" id="post"><header class="post-header text-center"><h1 class="title">Java面向对象之三大特性</h1><span><time class="time" datetime="2017-03-29T15:28:14.000Z">2017-03-29 </time></span><span class="slash">/</span> <span class="post-meta"><span class="post-tags"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/多态/">多态</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/封装/">封装</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/继承/">继承</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/面向对象/">面向对象</a></li></ul></span></span><span class="slash">/</span> <span class="read"><span id="busuanzi_value_page_pv"></span> 点击 </span><span class="slash">/</span></header><div class="post-content"><p>Java 语言重要思想即面向对象，一切皆对象，且具有三大特征：继承、封装 、多态。面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。可以将复杂的业务逻辑简单化，增强代码的复用性，亦而比较符合人们的思考习惯。</p><a id="more"></a><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a><strong>类和对象</strong></h3><p>（1）类：类是对某一类事物的抽象描述，是对象的模板，确定对象将会拥有的特征(属性)和行为(方法)。</p><p>​ 特点：类是具有相同属性和方法的一组对象的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line"><span class="comment">//可编写0至n个属性</span></span><br><span class="line">数据类型 变量名<span class="number">1</span>;</span><br><span class="line">数据类型 变量名<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//可编写0至n个方法</span></span><br><span class="line">修饰符 返回值类型 方法名(参数)&#123;</span><br><span class="line">	执行语句;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）对象：用于描述现实中的个体,它是类的实例。</p><p>创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名()</span><br><span class="line"></span><br><span class="line">对象.属性   /   对象.方法名()</span><br></pre></td></tr></table></figure><p>（3）成员变量与局部变量</p><p>成员变量：在类中定义，用来描述对象将要有什么。（作用域在整个类内部都是可见的）</p><p>局部变量：在类的方法中定义，在方法中临时保存数据。（作用域仅限于定义它的方法）</p><p>区别：</p><ul><li>作用域不同</li><li>两类变量同名时，局部变量的优先级更高</li><li>初始值不同：Java会给成员变量一个初始值，不会给局部变量赋予初始值</li></ul><p>（4）构造方法：定义在Java中的一个用来初始化对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义格式</span></span><br><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">	…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用new+构造方法 创建一个新的对象。</li><li>名称与类名相同且没有返回值。</li><li>当没有指定构造方法时，系统会自动添加无参的构造方法。</li><li>当有指定构造方法时，无论是有参、无参的构造方法，都不会自动添加无参的构造方法。</li><li>构造方法可重载：方法名相同，但参数不同，调用时会自动根据不同的参数选择相应的方法。</li><li>构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值（在构造函数中增加判断）。</li></ul><p>（5）static静态变量（也称类成员）</p><ul><li>它属于整个类所有，而不是某个对象所有，被类的所有对象所共享。</li><li>静态成员可使用类名直接访问，也可以使用对象名进行访问。</li><li>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收。</li></ul><p>（6）static静态方法（也称类方法）</p><ul><li>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。</li><li>如果系统在静态方法中调用非静态变量，可通过创建类的对象，然后通过对象来访问非静态变量。</li><li>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。</li><li>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。</li></ul><p>（7）初始化块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.普通初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">	xxx = xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	xxx = xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***执行顺序：静态初始化块最先被执行--&gt;普通初始化块--&gt;构造方法</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面向对象共有三个特征:封装,继承,多态</span></span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><p>（1）概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法类实现对隐藏信息的操作和访问。</p><p>（2）好处：只能同规定的方法访问数据，隐藏类的实现细节，方便修改和实现，提高了代码的复用性以及安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如: Arrays.sort(arr);//完成排序 sort方法封装了排序的算法</span></span><br></pre></td></tr></table></figure><p>（3）实现步骤</p><ol><li>修改属性的可见性：设为private</li><li>创建getter/setter方法：用于属性的读写</li><li>在getter/setter方法中加入属性控制语句：对属性值的合法性进行判断</li></ol><p>（4）Java中的包</p><ul><li>作用：管理Java文件，解决同名文件的冲突</li><li>必须放在Java源程序的第一行，包名间用”.”号隔开</li><li>包的使用：可以通过import关键字在某个文件中使用其它文件中的类，Java包的命名是全小写字母</li></ul><p>（5）Java中的访问修饰符：可以修饰属性和方法的访问范围</p><ul><li>private：只能在本类中访问和使用。</li><li>default(默认)：能在本类和同包中访问和使用。</li><li>protected：能在本类、同包、子类中使用。</li><li>public：在本类、同包、子类、其它类中使用。</li></ul><p>（6）Java中this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表当前对象,即本类对象的引用</span></span><br><span class="line"><span class="comment">//this是在方法中使用的,哪个对象调用了该方法,this就代表调用该方法的对象引用</span></span><br><span class="line"><span class="comment">//this什么时候存在的?当创建对象的时候,this存在的</span></span><br><span class="line"><span class="comment">//this的作用:用来区别同名的成员变量与局部变量(this.成员变量)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.属性：操作当前对象的属性</span><br><span class="line"><span class="keyword">this</span>.方法：调用当前对象的方法</span><br></pre></td></tr></table></figure><p>（7）内部类：定义在另外一个类里面的类。</p><p>作用：</p><ul><li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据。</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时候使用内部类更方便。</li></ul><p>分类：成员内部类，静态内部类，方法内部类，匿名内部类。</p><p>（8）成员内部类(也称普通内部类)</p><ul><li>内部类定义在外部类内部，相当于外部类的一个成员变量的位置，内部类可以使用任意访问控制符。</li><li>内部类中的方法可以直接访问外部类中的数据，而不受访问控制符的影响。</li><li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即： 内部类 对象名 = 外部类对象.new 内部类()</span></span><br></pre></td></tr></table></figure><ul><li>外部类不能直接使用内部类的成员和方法，创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</li><li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可使用：外部类.this.对象名</li></ul><p>（9）静态内部类(static修饰的内部类)</p><ul><li>静态内部类不能直接访问外部类的非静态成员，但可通过”new 外部类().成员”的方式访问</li><li>如果外部类的静态成员与内部类的成员名称相同，可通过”类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过”成员名” 直接调用。</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建：内部类 对象名 = new 内部类();</li></ul><p>（10）方法内部类</p><p>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</p><p>注意：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制修饰符和static修饰符。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>概念：</p><p>​ 指在一个现有类的基础上去构建一个新的类,构建出来的新类被称作子类,现有类被称作父类,子类会自动拥有父类所有的非私有属性和方法。</p><p>继承的优点：</p><ul><li>提高代码复用性</li><li>父类的属性方法可以用于子类</li><li>利于程序的设计，使设计应用程序变得简单</li><li>易于扩展</li></ul><p>继承的缺点：</p><ul><li>继承是侵入性的，只要继承，就必须拥有父类的所有属性和方法</li><li>降低了代码的灵活性</li><li>增强了耦合性</li><li>打破了封装性</li></ul><p>（1）继承时类与类的一种关系，是一种”is a”的关系</p><p>（2）Java中的继承时单继承，只有一个父类</p><p>（3）class 子类 extends 父类</p><p>（4）方法的重写</p><ul><li>子类可重写从父类继承的方法，当调用方法时会优先调用子类的方法。</li><li>返回值类型、方法名、参数类型及个数 都要与父类继承的方法相同，才叫方法的重写。</li></ul><p>（5）继承的初始化顺序</p><ul><li>初始化父类再初始化子类</li><li>属性的初始化在构造方法之前执行。</li><li>父类的属性初始化–&gt;父类的构造函数–&gt;子类的属性初始化–&gt;子类的构造函数</li></ul><p>（6）final</p><p>可修饰类、方法、属性和变量</p><ul><li>final修饰类，则该类不允许被继承</li><li>final修饰方法，则该方法不允许被覆盖(重写)</li><li>final修饰属性，则该类的属性不会进行隐式初始化（类的初始化属性必须有值）或在构造方法中赋值（只能任选其一）</li><li>final修饰变量，则该变量的值只能赋一次值，即变为常量</li></ul><p>（7）super关键字</p><p>在对象的内部使用，可以代表父类，指的是父类的存储空间(理解为父类的引用)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用父类的成员变量:</span></span><br><span class="line"><span class="keyword">super</span>.成员变量;</span><br><span class="line"><span class="comment">//调用父类的构造方法:</span></span><br><span class="line"><span class="keyword">super</span>(参数);</span><br><span class="line"><span class="comment">//调用方法的成员方法:</span></span><br><span class="line"><span class="keyword">super</span>.成员方法();</span><br><span class="line">**在创建子类对象时,父类的构造方法会先执行,因为子类中所有构造方法的第一行有默认的隐式<span class="keyword">super</span>();语句。</span><br><span class="line"><span class="comment">//调用本类中的构造方法</span></span><br><span class="line"><span class="keyword">this</span>(实参列表);</span><br><span class="line"><span class="comment">//调用父类中的空参数构造方法</span></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="comment">//调用父类中的有参数构造方法</span></span><br><span class="line"><span class="keyword">super</span>(实参列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当在方法中出现了局部变量和成员变量同名的时候,可以在成员变量名前面加上this.来区别成员变量和局部变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子父类中出现了同名成员变量时,在子类中若要访问父类中的成员变量,必须使用关键字super来完成。super用来表示当前对象中包含的父类对象空间的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在子类中,访问父类中的成员变量格式:</span></span><br><span class="line"><span class="keyword">super</span>.父类中的成员变量</span><br><span class="line">System.out.println(“Fu num=”+<span class="keyword">super</span>.num);</span><br><span class="line"><span class="comment">//访问子类中的num2</span></span><br><span class="line">System.out.println(“Zi num2=”+<span class="keyword">this</span>.num);</span><br><span class="line"><span class="comment">//在子类中,访问父类中的成员方法格式:</span></span><br><span class="line"><span class="keyword">super</span>.父类中的成员方法();</span><br></pre></td></tr></table></figure><p>（8）Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另一个类，那么这个类默认继承Object类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><ul><li><p>继承是多态实现的基础，理解为同一种物质的多种形态。</p></li><li><p>使用前提：有继承或者实现关系</p></li><li><p>好处：提高了程序的扩展性</p></li><li><p>弊端：不能访问子类特有功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg：</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(“重写父类抽象方法”);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的多态使用</span></span><br><span class="line">Fu fu= <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li></ul><p>（1）引用多态：父类的引用可以指向本类的对象/父类的引用可以指向子类的对象。</p><p>（2）方法多态：创建本类对象时，调用的方法为本类方法/创建子类对象时，调用的方法为子类重写的方法或继承的方法。</p><p>（3）引用类型转换</p><ul><li>向上类型转换：隐式/自动类型转换，小类型到大类型的转换。（无风险）</li><li>向下类型转换：强制类型转换，是大类型到小类型。（有风险）</li></ul><p>（4）抽象类</p><p>应用场景：在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。</p><ul><li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。</li><li>限制规定子类必须实现某些方法，但不关注实现细节。</li><li>abstract定义抽象类</li><li>abstract定义抽象方法，只有声明，不需要实现</li><li>包含抽象方法的类是抽象类</li><li>抽象类中可以包含普通的方法，也可以没有抽象方法</li><li>抽象类不能直接创建，可以定义引用变量</li></ul><p>（5）接口</p><ul><li>接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。</li><li>类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。</li><li>接口定义的基本语法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口1, 父接口2]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1</span>-n常量定义...</span><br><span class="line">	</span><br><span class="line">	<span class="number">1</span>-n抽象方法的定义....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的多态</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(“重写接口抽象方法”);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的多态使用</span></span><br><span class="line">Fu fu = <span class="keyword">new</span> Zi()</span><br></pre></td></tr></table></figure><ul><li>Java中一个类只能有一个父类，不够灵活，可通过实现多个接口增加灵活性。</li><li>接口中属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上。</li><li>接口中方法只能是抽象方法，系统会自动添加public abstract</li></ul><p>抽象类和接口的区别（表格来源：<a href="http://www.importnew.com/12399.html）" target="_blank" rel="noopener">http://www.importnew.com/12399.html）</a></p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz4v0go92sj30lo0kdtb2.jpg" alt="抽象类和接口的区别"></p><p>（6）UML</p><p>概念：统一建模语言或标准建模语言，支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。</p><p>常用的UML图:</p><p>用例图：能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求信息。</p><p>序列图：用于安置交互发生的一系列顺序，显示对象之间的这些交互。</p><p>类图：UML类图、业务逻辑和所有支持结构被用于定义全部的代码结构。</p></div><div style="color:#2196F3">---------------------------------------------本文完，感谢您的阅读---------------------------------------------</div></article><div class="toc-container"><div id="toc" class="toc-article"><strong class="toc-title">目录</strong><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#类和对象"><span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-text">多态</span></a></li></ol></div></div></div><div class="copyright"><span>本作品采用</span> <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> <span>进行许可。 转载时请注明原文链接。</span></div><div class="share" style="width:100%"><img src="http://wx4.sinaimg.cn/mw690/0077hIeDly1fz58snp402j308c08ct8k.jpg" alt="Running Geek" style="margin:auto;display:block"><div style="margin:auto;text-align:center;font-size:.9em;color:grey;color:#2196f3">Learn from each other</div></div><div class="post-nav"><div class="post-nav-item post-nav-next"><span>〈 </span><a href="/2017/03/20/浅谈Arrays.asList()抛出UnsupportOperationException异常/" rel="next" title="浅谈Arrays.asList()抛出UnsupportOperationException异常">浅谈Arrays.asList()抛出UnsupportOperationException异常</a></div><div class="post-nav-item post-nav-prev"><a href="/2017/04/11/集合框架(一)/" rel="prev" title="集合框架(一)">集合框架(一) </a><span>〉</span></div></div><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section><script>var disqus_shortname="XXX",disqus_url="https://swushxw.github.io/2017/03/29/Java面向对象知识点总结/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/count.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//XXX.disqus.com/count.js" async></script></div></div><footer class="footer text-center"><div id="bottom-inner"><a class="bottom-item" href="https://github.com/SwuShxw/swushxw.github.io.git">首页</a> | <a class="bottom-item" href="https://github.com/SwuShxw" target="_blank">GitHub</a> | <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> | <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a></div></footer><script>!function(e,t,n){function o(){cancelAnimationFrame(d),d=requestAnimationFrame(function e(){var n=t.body.scrollTop||t.documentElement.scrollTop;n>0?(t.body.scrollTop=t.documentElement.scrollTop=n-50,d=requestAnimationFrame(e)):cancelAnimationFrame(d)})}function a(){c(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),r(),i(),m()}function i(){for(var e=0;e<u.length;e++)u[e].alpha<=0?(t.body.removeChild(u[e].el),u.splice(e,1)):(u[e].y--,u[e].scale+=.004,u[e].alpha-=.013,u[e].el.style.cssText="left:"+u[e].x+"px;top:"+u[e].y+"px;opacity:"+u[e].alpha+";transform:scale("+u[e].scale+","+u[e].scale+") rotate(45deg);background:"+u[e].color);requestAnimationFrame(i)}function r(){var n="function"==typeof e.onclick&&e.onclick,a=t.getElementById("logo");a&&(a.onclick=function(e){o(),n&&n(),l(e)})}function l(e){var n=t.createElement("div");n.className="heart",u.push({el:n,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(n)}function c(e){var n=t.createElement("style");n.type="text/css";try{n.appendChild(t.createTextNode(e))}catch(o){n.styleSheet.cssText=e}t.getElementsByTagName("head")[0].appendChild(n)}function s(){return"#F44336"}function m(){var e=t.getElementById("menu-main-post");if(e){var n=t.getElementById("toc");n?e.onclick=function(){n&&("block"==n.style.display?n.style.display="none":n.style.display="block")}:e.style.display="none"}}var d=null,u=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),a()}(window,document)</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?FuckUBaidu";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","XXX","auto"),ga("send","pageview")</script><script type="text/javascript" src="/js/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by neat -->