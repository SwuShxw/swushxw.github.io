<!-- build time:Fri Jan 25 2019 22:51:49 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="theme-color" content="#202020"><meta http-equiv="x-ua-compatible" content="ie=edge"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><meta name="keywords" content="Java,集合,List,Map,Set,Collection,"><meta name="description" content="集合框架(一)"><link rel="icon" type="image/x-icon" href="/img/swuixw.png"><title>集合框架(一) [ 筱炜的博客 ]</title><link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" href="/css/xoxo.css"></head><body><div class="nav-container"><nav class="home-menu pure-menu pure-menu-horizontal"><a class="pure-menu-heading" href="/"><img class="avatar" src="https://swushxw.github.io/img/swuixw.png"> <span class="title">筱炜的博客</span></a><ul class="pure-menu-list clearfix"><li class="pure-menu-item"><a href="/" class="pure-menu-link">首页</a></li><li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li><li class="pure-menu-item"><a href="/tags" class="pure-menu-link">标签</a></li><li class="pure-menu-item"><a href="/categories" class="pure-menu-link">分类</a></li><li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li></ul></nav></div><div class="container" id="content-outer"><div class="inner" id="content-inner"><div class="post-container"><article class="post" id="post"><header class="post-header text-center"><h1 class="title">集合框架(一)</h1><span><time class="time" datetime="2017-04-11T02:36:27.000Z">2017-04-11 </time></span><span class="slash">/</span> <span class="post-meta"><span class="post-tags"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/Collection/">Collection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/List/">List</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/Map/">Map</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/Set/">Set</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/public/tags/集合/">集合</a></li></ul></span></span><span class="slash">/</span> <span class="read"><span id="busuanzi_value_page_pv"></span> 点击 </span><span class="slash">/</span></header><div class="post-content"><p>集合是java中提供的一种容器，可以用来存储多个数据，集合类存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用（reference)。 集合类型主要有3种：set(集）、list(列表）和map(映射)。 集合接口分为：Collection和Map，list、set实现了Collection接口。</p><a id="more"></a><p>在此多啰嗦一点，前面文章提到数组，数组与集合都是容器，那他们之间到底有什么区别呢？区别主要分一下两点（在实际开发中灵活运用，大多数使用集合）</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a><strong>集合框架</strong></h3><p>来一张集合框架图（图片来源：<a href="https://liujiacai.net/blog/2015/09/01/java-collection-overview/）" target="_blank" rel="noopener">https://liujiacai.net/blog/2015/09/01/java-collection-overview/）</a></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB21HYoeVXXXXaLXXXXXXXXXXXX_!!581166664.jpeg" alt="集合框架图"></p><p>常用四个接口的区别：</p><p>1、collection:存储不唯一、无序的数据；</p><p>2、list：存储有序的、不唯一的数据；</p><p>3、set：存储无序的、唯一的数据；</p><p>4、Map：以键值对的形式存储数据，以键取值。键不能重复、值可以重复。</p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h4><p>是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用<br>的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li>public boolean add(E e) ： 把给定的对象添加到当前集合中 。</li><li>public void clear() :清空集合中所有的元素。</li><li>public boolean remove(E e) : 把给定的对象在当前集合中删除。</li><li>public boolean contains(E e) : 判断当前集合中是否包含给定的对象。</li><li>public boolean isEmpty() : 判断当前集合是否为空。</li><li>public int size() : 返回集合中元素的个数。</li><li>public Object[] toArray() : 把集合中的元素，存储到数组中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合对象</span></span><br><span class="line">        <span class="comment">// 使用多态形式</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 使用方法</span></span><br><span class="line">        <span class="comment">// 添加功能 boolean add(String s)</span></span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">        <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">        System.out.println(<span class="string">"判断 str1 是否在集合中"</span>+coll.contains(<span class="string">"str1"</span>));</span><br><span class="line">        <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">        System.out.println(<span class="string">"删除str2："</span>+coll.remove(<span class="string">"str2"</span>));</span><br><span class="line">        System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">        <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">        System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line">        <span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">        Object[] objects = coll.toArray();</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        System.out.println(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// void clear() 清空集合</span></span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line">        <span class="comment">// boolean isEmpty() 判断是否为空</span></span><br><span class="line">        System.out.println(coll.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a><strong>Iterator迭代器</strong></h4><p><strong>Iterator接口</strong></p><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接 口 java.util.Iterator 。 Iterator 接口也是Java集合中的一员，但它 与 Collection 、 Map 接口有所不同， Collection 接口与 Map 接口主要用于存储元素， 而 Iterator 主要用于迭代访问（即遍历） Collection 中的元素，因此 Iterator 对象也 被称为迭代器。<br>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取 迭代器的方法：</p><ul><li>public Iterator iterator() : 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>迭代的概念：</p><p>即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有 元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把 集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><p>Iterator接口的常用方法如下：</p><ul><li>public E next() :返回迭代的下一个元素。</li><li>public boolean hasNext() :如果仍有元素可以迭代，则返回 true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历 每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">// 泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">        String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器的实现原理</strong></p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p><p>首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><p>当然，迭代器在开发中基本不用，一般使用增强for，在学习阶段也是必须了解的内容。</p><p><strong>增强for</strong></p><p>增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数<br>组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合<br>中的元素进行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 : Collection集合or数组)&#123;</span><br><span class="line">	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进<br>行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg1</span></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="comment">//使用增强for遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">        	System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg2</span></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">        	System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h4><p>List集合包括List接口以及List接口接口的所有实现类，List集合中的元素允许重复，各元素的顺序就是对象插入的顺序，类似Java数组，用户可通过使用索引来访问集合中的元素。</p><h5 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><strong>List接口</strong></h5><p>java.util.List 接口继承自Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了List 接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>List接口特点</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、<br>22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><p>List接口中常用方法：</p><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操<br>作集合的特有方法，如下：</p><ul><li>public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。</li><li>public E get(int index) :返回集合中指定位置的元素。</li><li>public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li>public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List的子类</p><h5 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a><strong>ArrayList集合</strong></h5><p>java.util.ArrayList 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList 是最常用的集合。</p><h5 id="LinkedList集合："><a href="#LinkedList集合：" class="headerlink" title="LinkedList集合："></a><strong>LinkedList集合：</strong></h5><p>java.util.LinkedList 集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDgy1fz5f1r4fuzj30vb0f8tak.jpg" alt="LinkedList "></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方<br>法我们作为了解即可：</p><ul><li>public void addFirst(E e) :将指定元素插入此列表的开头。</li><li>public void addLast(E e) :将指定元素添加到此列表的结尾。</li><li>public E getFirst() :返回此列表的第一个元素。</li><li>public E getLast() :返回此列表的最后一个元素。</li><li>public E removeFirst() :移除并返回此列表的第一个元素。</li><li>public E removeLast() :移除并返回此列表的最后一个元素。</li><li>public E pop() :从此列表所表示的堆栈处弹出一个元素。</li><li>public void push(E e) :将元素推入此列表所表示的堆栈。</li><li>public boolean isEmpty() ：如果列表不包含元素，则返回true。</li></ul><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h5><p>对于Vector，它是jdk1.0就留下来的，它和ArrayList是类似的，不同点就是，它是线程安全的，在多线程的环境下使用其可能有好处，但是非多线程情况下使用效率会很低。</p><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h4><p>Set集合中的对象不按特定的方式排序，只是简单的把对象加入集合中，但Set集合中不能包含重复对象，Set集合由Set接口和Set接口的实现类组成，Set接口继承了Collection接口，因此包含Collection的所有方法。</p><h5 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a><strong>set接口</strong></h5><p>java.util.Set 接口和java.util.List 接口一样，同样继承自Collection 接口，它与Collection 接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比Collection 接口更加严格了。与List 接口不同的是， Set 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p>Set 集合有多个子类，这里我们介绍其中的java.util.HashSet 、java.util.LinkedHashSet 这两个集合。其他不常用。</p><p>java.util.HashSet 是Set 接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序<br>不一致)。java.util.HashSet 底层的实现其实是一个java.util.HashMap 支持，后面会将HashMap。</p><p>HashSet 是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于： hashCode 与equals 方法。</p><h5 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a><strong>HashSet集合存储数据的结构（哈希表）</strong></h5><p>什么是哈希表呢？<br>在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。<br>但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈<br>希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找<br>时间。<br>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p><p>（图片来源：<a href="https://blog.csdn.net/login_sonata/article/details/76598675）" target="_blank" rel="noopener">https://blog.csdn.net/login_sonata/article/details/76598675）</a></p><p><img src="https://img-blog.csdn.net/20170803204952538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG9naW5fc29uYXRh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>为了方便理解，附HashSet存储原理图（即HashMap底层）（图片来源网络，具体不详）</p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz5focw9yyj30sp0qw0xg.jpg" alt="hashmap底层"></p><h5 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a><strong>LinkedHashSet类</strong></h5><p>LinkedHashSet类也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序。与HashSet相比，特点：</p><ol><li>对集合迭代时，按增加顺序返回元素。</li><li>性能略低于HashSet，因为需要维护元素的插入顺序。但迭代访问元素时会有好性能，因为它采用链表维护内部顺序。</li></ol><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a><strong>Map集合</strong></h4><p>Map集合提供的是key到value的映射，Map中不能包含相同的key，每个key只能映射一个value，key决定了存储对象在映射中的存储位置，但不是key对象本身决定的，而是由一种“散列技术”进行处理，产生一个散列码的整数值，散列码通常用作一个偏移量，该偏移量对应分配给映射的内存区域的起始位置，从而确定储存对象在映射中的储存位置，Map集合包括Map接口以及接口的所有实现类。</p><p>Map常用子类：</p><ul><li><p>HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需 要重写键的hashCode()方法、equals()方法。</p></li><li><p>LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链 表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。</p></li></ul><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><strong>Map接口</strong></h5><p>Map接口常用方法：</p><ul><li>public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。</li><li>public V remove(Object key) : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li>public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</li><li>public Set<k>keySet() : 获取Map集合中所有的键，存储到Set集合中。</k></li><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">"s2"</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"s1"</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">"s3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a><strong>Map集合遍历键找值方式</strong></h5><p>键找值方式：即通过元素中的键，获取键所对应的值<br>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示: keyset()</li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示: get(K key)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//获取所有的键 获取键集</span></span><br><span class="line">            Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="comment">//key 就是键</span></span><br><span class="line">        <span class="comment">//获取对应值</span></span><br><span class="line">        String value = map.get(key);</span><br><span class="line">        	System.out.println(key+<span class="string">"的value是："</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a><strong>Entry键值对对象</strong></h5><p>Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map 中是一一对应关系，这一对对象又称做Map 中的一个Entry(项) 。Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。</p><p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li>public K getKey() ：获取Entry对象中的键。</li><li>public V getValue() ：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h5 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a><strong>Map集合遍历键值对方式</strong></h5><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>分析步骤：</p><ol><li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示: entrySet() 。</li><li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li>通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示: getkey() getValue()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象 entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        System.out.println(key+<span class="string">"的value是:"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h4><p>HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，要保证有序，还要速度快就要使用HashMap下面的一个子类LinkedHashMap，是链表和哈希表组合的一个数据存储结构。完美解决以上问题</p><h4><a href="#" class="headerlink"></a></h4><h4 id="-1"><a href="#-1" class="headerlink"></a></h4><h4 id="-2"><a href="#-2" class="headerlink"></a></h4><h4 id="-3"><a href="#-3" class="headerlink"></a></h4><h4 id="-4"><a href="#-4" class="headerlink"></a></h4><h4 id="-5"><a href="#-5" class="headerlink"></a></h4></div><div style="color:#2196F3">---------------------------------------------本文完，感谢您的阅读---------------------------------------------</div></article><div class="toc-container"><div id="toc" class="toc-article"><strong class="toc-title">目录</strong><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#集合框架"><span class="toc-text">集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection接口"><span class="toc-text">Collection接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator迭代器"><span class="toc-text">Iterator迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List集合"><span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#List接口"><span class="toc-text">List接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList集合"><span class="toc-text">ArrayList集合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList集合："><span class="toc-text">LinkedList集合：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set集合"><span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set接口"><span class="toc-text">set接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashSet集合存储数据的结构（哈希表）"><span class="toc-text">HashSet集合存储数据的结构（哈希表）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedHashSet类"><span class="toc-text">LinkedHashSet类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map集合"><span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Map接口"><span class="toc-text">Map接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map集合遍历键找值方式"><span class="toc-text">Map集合遍历键找值方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Entry键值对对象"><span class="toc-text">Entry键值对对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map集合遍历键值对方式"><span class="toc-text">Map集合遍历键值对方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-3"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-4"><span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-5"><span class="toc-text"></span></a></li></ol></li></ol></div></div></div><div class="copyright"><span>本作品采用</span> <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> <span>进行许可。 转载时请注明原文链接。</span></div><div class="share" style="width:100%"><img src="http://wx4.sinaimg.cn/mw690/0077hIeDly1fz58snp402j308c08ct8k.jpg" alt="Running Geek" style="margin:auto;display:block"><div style="margin:auto;text-align:center;font-size:.9em;color:grey;color:#2196f3">Learn from each other</div></div><div class="post-nav"><div class="post-nav-item post-nav-next"><span>〈 </span><a href="/2017/03/29/Java面向对象知识点总结/" rel="next" title="Java面向对象之三大特性">Java面向对象之三大特性</a></div><div class="post-nav-item post-nav-prev"><a href="/2017/04/12/集合框架(二)-浅谈单列&amp;双列集合底层数据结构/" rel="prev" title="集合框架(二)-单列&amp;双列集合底层数据结构">集合框架(二)-单列&amp;双列集合底层数据结构 </a><span>〉</span></div></div><section class="disqus-comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section><script>var disqus_shortname="XXX",disqus_url="https://swushxw.github.io/2017/04/11/集合框架(一)/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/count.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//XXX.disqus.com/count.js" async></script></div></div><footer class="footer text-center"><div id="bottom-inner"><a class="bottom-item" href="https://github.com/SwuShxw/swushxw.github.io.git">首页</a> | <a class="bottom-item" href="https://github.com/SwuShxw" target="_blank">GitHub</a> | <a class="bottom-item" href="https://hexo.io" target="_blank">Powered by hexo</a> | <a class="bottom-item" href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank">Theme xoxo</a></div></footer><script>!function(e,t,n){function o(){cancelAnimationFrame(d),d=requestAnimationFrame(function e(){var n=t.body.scrollTop||t.documentElement.scrollTop;n>0?(t.body.scrollTop=t.documentElement.scrollTop=n-50,d=requestAnimationFrame(e)):cancelAnimationFrame(d)})}function a(){c(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),r(),i(),m()}function i(){for(var e=0;e<u.length;e++)u[e].alpha<=0?(t.body.removeChild(u[e].el),u.splice(e,1)):(u[e].y--,u[e].scale+=.004,u[e].alpha-=.013,u[e].el.style.cssText="left:"+u[e].x+"px;top:"+u[e].y+"px;opacity:"+u[e].alpha+";transform:scale("+u[e].scale+","+u[e].scale+") rotate(45deg);background:"+u[e].color);requestAnimationFrame(i)}function r(){var n="function"==typeof e.onclick&&e.onclick,a=t.getElementById("logo");a&&(a.onclick=function(e){o(),n&&n(),l(e)})}function l(e){var n=t.createElement("div");n.className="heart",u.push({el:n,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(n)}function c(e){var n=t.createElement("style");n.type="text/css";try{n.appendChild(t.createTextNode(e))}catch(o){n.styleSheet.cssText=e}t.getElementsByTagName("head")[0].appendChild(n)}function s(){return"#F44336"}function m(){var e=t.getElementById("menu-main-post");if(e){var n=t.getElementById("toc");n?e.onclick=function(){n&&("block"==n.style.display?n.style.display="none":n.style.display="block")}:e.style.display="none"}}var d=null,u=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),a()}(window,document)</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?FuckUBaidu";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","XXX","auto"),ga("send","pageview")</script><script type="text/javascript" src="/js/love.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by neat -->