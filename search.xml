<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F01%2F19%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker简介虚拟化​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。 ​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 ​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 Docker ​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 ​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 ​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 ​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 Docker特点 （1）上手快。 ​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。 ​ 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。 （2）职责的逻辑分类 ​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）” （3）快速高效的开发生命周期 ​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。） （4）鼓励使用面向服务的架构 ​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序） 容器与虚拟机比较 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 Docker 组件Docker服务器与客户端 Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 Docker镜像与容器 镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如： 添加一个文件； 执行一个命令； 打开一个窗口。 也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。 ​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。 所以Docker容器就是： ​ 一个镜像格式； ​ 一些列标准操作； ​ 一个执行环境。 ​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 ​ 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。 ​ Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。 Registry（注册中心） Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。https://hub.docker.com/ Docker安装与启动安装DockerDocker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 ​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 ​ 请直接挂载课程配套的Centos7.x镜像 （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo （4）安装docker 1sudo yum install docker-ce （5）安装后查看docker版本 1docker -v 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vi /etc/docker/daemon.json 在该文件中输入如下内容： 123&#123; &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]&#125; Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 查看docker状态： 1systemctl status docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 查看docker帮助文档 1docker --help 常用命令镜像相关命令查看镜像 1docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker宿主机的/var/lib/docker目录下 搜索镜像 如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 1docker search 镜像名称 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 拉取镜像 拉取镜像就是从中央仓库中下载镜像到本地 1docker pull 镜像名称 例如，我要下载centos7镜像 1docker pull centos:7 删除镜像 按镜像ID删除镜像 1docker rmi 镜像ID 删除所有镜像 1docker rmi `docker images -q` 容器相关命令查看容器 查看正在运行的容器 1docker ps 查看所有容器 1docker ps –a 查看最后一次运行的容器 1docker ps –l 查看停止的容器 1docker ps -f status=exited 创建与启动容器 创建容器常用的参数说明： 创建容器命令：docker run -i：表示运行容器 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。 –name :为创建的容器命名。 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 1docker run -it --name=容器名称 镜像名称:标签 /bin/bash 这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态 退出当前容器 1exit （2）守护式方式创建容器： 1docker run -di --name=容器名称 镜像名称:标签 登录守护式容器方式： 1docker exec -it 容器名称 (或者容器ID) /bin/bash 停止与启动容器 停止容器： 1docker stop 容器名称（或者容器ID） 启动容器： 1docker start 容器名称（或者容器ID） 文件拷贝 如果我们需要将文件拷贝到容器内可以使用cp命令 1docker cp 需要拷贝的文件或目录 容器名称:容器目录 也可以将文件从容器内拷贝出来 1docker cp 容器名称:容器目录 需要拷贝的文件或目录 目录挂载 我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 查看容器IP地址 我们可以通过以下命令查看容器运行的各种数据 1docker inspect 容器名称（容器ID） 也可以直接执行下面的命令直接输出IP地址 1docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; 容器名称（容器ID） 删除容器 删除指定的容器： 1docker rm 容器名称（容器ID） 应用部署MySQL部署（1）拉取mysql镜像 1docker pull centos/mysql-57-centos7 （2）创建容器 1docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql -p 代表端口映射，格式为 宿主机映射端口:容器运行端口 -e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 （2）创建容器 创建容器 -p表示地址映射 12docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name=mynginx -p 80:80 nginx Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name=myredis -p 6379:6379 redis 迁移与备份容器保存为镜像 我们可以通过以下命令将容器保存为镜像 1docker commit mynginx mynginx_i 镜像备份 我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 镜像恢复与迁移 我们可以通过以下命令将镜像保存为tar 文件 1docker save -o mynginx.tar mynginx_i 镜像恢复与迁移 首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 1docker load -i mynginx.tar -i 输入的文件 执行后再次查看镜像，可以看到镜像已经恢复 DockerfileDockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境； 2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了； 3、对于运维人员：在部署时，可以实现应用的无缝移植。 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p /usr/local/dockerjdk8 （2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vi Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:7#指定镜像创建者信息MAINTAINER ITCAST#切换工作目录WORKDIR /usrRUN mkdir /usr/local/java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/#配置java环境变量ENV JAVA_HOME /usr/local/java/jdk1.8.0_171ENV JRE_HOME $JAVA_HOME/jreENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATHENV PATH $JAVA_HOME/bin:$PATH （4）执行命令构建镜像 1docker build -t=&apos;jdk1.8&apos; . 注意后边的空格和点，不要省略 （5）查看镜像是否建立完成 1docker images Docker私有仓库私有仓库搭建与配置（1）拉取私有仓库镜像（此步省略） 1docker pull registry （2）启动私有仓库容器 1docker run -di --name=registry -p 5000:5000 registry （3）打开浏览器 输入地址http://192.168.184.141:5000/v2/_catalog看到{&quot;repositories&quot;:[]} 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vi /etc/docker/daemon.json 添加以下内容，保存退出。 1&#123;&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]&#125; 此步用于让 docker信任私有仓库地址 （5）重启docker 服务 1systemctl restart docker 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 1docker tag jdk1.8 192.168.184.141:5000/jdk1.8 （2）再次启动私服容器 1docker start registry （3）上传标记的镜像 1docker push 192.168.184.141:5000/jdk1.8 文章来源互联网，具体不详]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js]]></title>
    <url>%2F2019%2F01%2F18%2FVue%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络程序设计]]></title>
    <url>%2F2017%2F05%2F19%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Thread/多线程]]></title>
    <url>%2F2017%2F05%2F13%2FThread%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2017%2F04%2F27%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Reflect</tag>
        <tag>Class</tag>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I/O流]]></title>
    <url>%2F2017%2F04%2F20%2FIO%E6%B5%81%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O流</tag>
        <tag>Reder</tag>
        <tag>Writer</tag>
        <tag>InputStream</tag>
        <tag>OutputStream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架(二)-HashMap底层实现原理]]></title>
    <url>%2F2017%2F04%2F12%2F%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%BA%8C)-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[先来了解哈希表，什么是哈希表呢？在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。 但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈 希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找 时间。 HashMap的底层实现原理HashMap的数据结构数据结构中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。 数组： 数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难； 链表： 链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。 哈希表： 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。 哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“链表的数组” ，如图： ​ 从上图我们可以发现哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。 ​ HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。 ​ 首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。 1234/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry[] table; HashMap的存取实现既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现： 123456789// 存储时:int hash = key.hashCode(); // 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值int index = hash % Entry[].length;Entry[index] = value;// 取值时:int hash = key.hashCode();int index = hash % Entry[].length;return Entry[index]; 1）put 疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？ 这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。也就是说数组中存储的是最后插入的元素。到这里为止，HashMap的大致实现，我们应该已经清楚了。 12345678910111213141516171819202122232425262728public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); //null总是放在数组的第一个链表中 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); //遍历链表 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //如果key在链表中已存在，则替换为新value if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125;void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); //参数e, 是Entry.next //如果size超过threshold，则扩充table大小。再散列 if (size++ &gt;= threshold) resize(2 * table.length);&#125; 当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。 2）get 1234567891011121314public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); //先定位到数组元素，再遍历该元素处的链表 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 3）null key的存取 123456789101112131415161718192021//null key总是存放在Entry[]数组的第一个元素。 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null; &#125; private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; 4）确定数组index：hashcode % table.length取模 1234567//HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下： /** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 5）table初始大小 12345678910public HashMap(int initialCapacity, float loadFactor) &#123; ..... // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)(capacity * loadFactor); table = new Entry[capacity]; init(); &#125; 注意table初始大小并不是构造函数中的initialCapacity！！ 而是 &gt;= initialCapacity的2的n次幂！！！！ ——为什么这么设计呢？—— 123来看看哈希冲突（来源：https://www.cnblogs.com/chengxiao/p/6059914.html）哈希冲突 然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式， 解决hash冲突的办法 开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列） 再哈希法 链地址法 建立一个公共溢出区 Java中hashmap的解决办法就是采用的链地址法。 再散列rehash过程当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Rehashes the contents of this map into a new array with a * larger capacity. This method is called automatically when the * number of keys in this map reaches its threshold. * * If current capacity is MAXIMUM_CAPACITY, this method does not * resize the map, but sets threshold to Integer.MAX_VALUE. * This has the effect of preventing future calls. * * @param newCapacity the new capacity, MUST be a power of two; * must be greater than current capacity unless current * capacity is MAXIMUM_CAPACITY (in which case value * is irrelevant). */ void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; /** * Transfers all entries from current table to newTable. */ void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; //重新计算index int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; 文章来源：https://www.cnblogs.com/holyshengjie/p/6500463.html 参考博文：https://www.cnblogs.com/chengxiao/p/6059914.html]]></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>HaspMap</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架(一)]]></title>
    <url>%2F2017%2F04%2F11%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合是java中提供的一种容器，可以用来存储多个数据，集合类存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用（reference)。 集合类型主要有3种：set(集）、list(列表）和map(映射)。 集合接口分为：Collection和Map，list、set实现了Collection接口。 在此多啰嗦一点，前面文章提到数组，数组与集合都是容器，那他们之间到底有什么区别呢？区别主要分一下两点（在实际开发中灵活运用，大多数使用集合） 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。 集合框架来一张集合框架图（图片来源：https://liujiacai.net/blog/2015/09/01/java-collection-overview/） 常用四个接口的区别： 1、collection:存储不唯一、无序的数据； 2、list：存储有序的、不唯一的数据； 3、set：存储无序的、唯一的数据； 4、Map：以键值对的形式存储数据，以键取值。键不能重复、值可以重复。 Collection接口是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e) ： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e) : 把给定的对象在当前集合中删除。 public boolean contains(E e) : 判断当前集合中是否包含给定的对象。 public boolean isEmpty() : 判断当前集合是否为空。 public int size() : 返回集合中元素的个数。 public Object[] toArray() : 把集合中的元素，存储到数组中。 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.Collection;public class CollectionDemo &#123; public static void main(String[] args) &#123; // 创建集合对象 // 使用多态形式 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 使用方法 // 添加功能 boolean add(String s) coll.add("str1"); coll.add("str2"); coll.add("str3"); System.out.println(coll); // boolean contains(E e) 判断o是否在集合中存在 System.out.println("判断 str1 是否在集合中"+coll.contains("str1")); //boolean remove(E e) 删除在集合中的o元素 System.out.println("删除str2："+coll.remove("str2")); System.out.println("操作之后集合中元素:"+coll); // size() 集合中有几个元素 System.out.println("集合中有"+coll.size()+"个元素"); // Object[] toArray()转换成一个Object数组 Object[] objects = coll.toArray(); // 遍历数组 for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; // void clear() 清空集合 coll.clear(); System.out.println("集合中内容为："+coll); // boolean isEmpty() 判断是否为空 System.out.println(coll.isEmpty()); &#125;&#125; Iterator迭代器Iterator接口在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接 口 java.util.Iterator 。 Iterator 接口也是Java集合中的一员，但它 与 Collection 、 Map 接口有所不同， Collection 接口与 Map 接口主要用于存储元素， 而 Iterator 主要用于迭代访问（即遍历） Collection 中的元素，因此 Iterator 对象也 被称为迭代器。想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取 迭代器的方法： public Iterator iterator() : 获取集合对应的迭代器，用来遍历集合中的元素的。 迭代的概念： 即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有 元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把 集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 Iterator接口的常用方法如下： public E next() :返回迭代的下一个元素。 public boolean hasNext() :如果仍有元素可以迭代，则返回 true。 12345678910111213141516171819//egpublic class IteratorDemo &#123; public static void main(String[] args) &#123; // 使用多态方式 创建对象 Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); // 添加元素到集合 coll.add("str1"); coll.add("str2"); coll.add("str3"); //遍历 //使用迭代器 遍历 每个集合对象都有自己的迭代器 Iterator&lt;String&gt; it = coll.iterator(); // 泛型指的是 迭代出 元素的数据类型 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s); &#125; &#125;&#125; 迭代器的实现原理Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。 首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。 当然，迭代器在开发中基本不用，一般使用增强for，在学习阶段也是必须了解的内容。 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。 1234567891011121314151617181920212223242526//eg1//遍历数组public class NBForDemo1 &#123; public static void main(String[] args) &#123; int[] arr = &#123;3,5,6,87&#125;; //使用增强for遍历数组 for(int a : arr)&#123;//a代表数组中的每个元素 System.out.println(a); &#125; &#125;&#125;//eg2//遍历集合public class NBFor &#123; public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); coll.add("str1"); coll.add("str2"); coll.add("str3"); //使用增强for遍历 for(String s :coll)&#123;//接收变量s代表 代表被遍历到的集合元素 System.out.println(s); &#125; &#125;&#125; List集合List集合包括List接口以及List接口接口的所有实现类，List集合中的元素允许重复，各元素的顺序就是对象插入的顺序，类似Java数组，用户可通过使用索引来访问集合中的元素。 List接口java.util.List 接口继承自Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了List 接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。 List接口特点 它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。 List接口中常用方法： List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下： public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。 public E get(int index) :返回集合中指定位置的元素。 public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List的子类 ArrayList集合java.util.ArrayList 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList 是最常用的集合。 LinkedList集合：java.util.LinkedList 集合数据存储的结构是链表结构。方便元素添加、删除的集合。 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e) :将指定元素插入此列表的开头。 public void addLast(E e) :将指定元素添加到此列表的结尾。 public E getFirst() :返回此列表的第一个元素。 public E getLast() :返回此列表的最后一个元素。 public E removeFirst() :移除并返回此列表的第一个元素。 public E removeLast() :移除并返回此列表的最后一个元素。 public E pop() :从此列表所表示的堆栈处弹出一个元素。 public void push(E e) :将元素推入此列表所表示的堆栈。 public boolean isEmpty() ：如果列表不包含元素，则返回true。 Vector对于Vector，它是jdk1.0就留下来的，它和ArrayList是类似的，不同点就是，它是线程安全的，在多线程的环境下使用其可能有好处，但是非多线程情况下使用效率会很低。 Set集合Set集合中的对象不按特定的方式排序，只是简单的把对象加入集合中，但Set集合中不能包含重复对象，Set集合由Set接口和Set接口的实现类组成，Set接口继承了Collection接口，因此包含Collection的所有方法。 set接口java.util.Set 接口和java.util.List 接口一样，同样继承自Collection 接口，它与Collection 接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比Collection 接口更加严格了。与List 接口不同的是， Set 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。 Set 集合有多个子类，这里我们介绍其中的java.util.HashSet 、java.util.LinkedHashSet 这两个集合。其他不常用。 java.util.HashSet 是Set 接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序不一致)。java.util.HashSet 底层的实现其实是一个java.util.HashMap 支持，后面会将HashMap。 HashSet 是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于： hashCode 与equals 方法。 HashSet集合存储数据的结构（哈希表）什么是哈希表呢？在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。 （图片来源：https://blog.csdn.net/login_sonata/article/details/76598675） 为了方便理解，附HashSet存储原理图（即HashMap底层）（图片来源网络，具体不详） LinkedHashSet类LinkedHashSet类也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序。与HashSet相比，特点： 对集合迭代时，按增加顺序返回元素。 性能略低于HashSet，因为需要维护元素的插入顺序。但迭代访问元素时会有好性能，因为它采用链表维护内部顺序。 Map集合Map集合提供的是key到value的映射，Map中不能包含相同的key，每个key只能映射一个value，key决定了存储对象在映射中的存储位置，但不是key对象本身决定的，而是由一种“散列技术”进行处理，产生一个散列码的整数值，散列码通常用作一个偏移量，该偏移量对应分配给映射的内存区域的起始位置，从而确定储存对象在映射中的储存位置，Map集合包括Map接口以及接口的所有实现类。 Map常用子类： HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需 要重写键的hashCode()方法、equals()方法。 LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链 表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。 Map接口Map接口常用方法： public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。 public V remove(Object key) : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 public Set keySet() : 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 1234567891011121314151617//egpublic class MapDemo &#123; public static void main(String[] args) &#123; //创建 map对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素到集合 map.put("s1", "str1"); map.put("s2", "str2"); map.put("s3", "str3"); System.out.println(map); //String remove(String key) System.out.println(map.remove("s2")); System.out.println(map); System.out.println(map.get("s1")); System.out.println(map.get("s3")); &#125;&#125; Map集合遍历键找值方式键找值方式：即通过元素中的键，获取键所对应的值分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示: keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示: get(K key) 1234567891011121314151617181920//egpublic class MapDemo01 &#123; public static void main(String[] args) &#123; //创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); //添加元素到集合 map.put("s1", "str1"); map.put("s2", "str2"); map.put("s3", "str3"); //获取所有的键 获取键集 Set&lt;String&gt; keys = map.keySet(); // 遍历键集 得到 每一个键 for (String key : keys) &#123; //key 就是键 //获取对应值 String value = map.get(key); System.out.println(key+"的value是："+value); &#125; &#125;&#125; Entry键值对对象Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map 中是一一对应关系，这一对对象又称做Map 中的一个Entry(项) 。Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey() ：获取Entry对象中的键。 public V getValue() ：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 Map集合遍历键值对方式键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。 分析步骤： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示: entrySet() 。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示: getkey() getValue() 1234567891011121314151617181920//egpublic class MapDemo02 &#123; public static void main(String[] args) &#123; // 创建Map集合对象 HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); // 添加元素到集合 map.put("s1", "str1"); map.put("s2", "str2"); map.put("s3", "str3"); // 获取 所有的 entry对象 entrySet Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet(); // 遍历得到每一个entry对象 for (Entry&lt;String, String&gt; entry : entrySet) &#123; // 解析 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"的value是:"+value); &#125; &#125;&#125; LinkedHashMapHashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，要保证有序，还要速度快就要使用HashMap下面的一个子类LinkedHashMap，是链表和哈希表组合的一个数据存储结构。完美解决以上问题]]></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>List</tag>
        <tag>Map</tag>
        <tag>Set</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象之三大特性]]></title>
    <url>%2F2017%2F03%2F29%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java 语言重要思想即面向对象，一切皆对象，且具有三大特征：继承、封装 、多态。面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。可以将复杂的业务逻辑简单化，增强代码的复用性，亦而比较符合人们的思考习惯。 类和对象（1）类：类是对某一类事物的抽象描述，是对象的模板，确定对象将会拥有的特征(属性)和行为(方法)。 ​ 特点：类是具有相同属性和方法的一组对象的集合。 12345678910//定义格式public class 类名 &#123;//可编写0至n个属性数据类型 变量名1;数据类型 变量名2; //可编写0至n个方法修饰符 返回值类型 方法名(参数)&#123; 执行语句; &#125;&#125; （2）对象：用于描述现实中的个体,它是类的实例。 创建对象： 123类名 对象名 = new 类名()对象.属性 / 对象.方法名() （3）成员变量与局部变量 成员变量：在类中定义，用来描述对象将要有什么。（作用域在整个类内部都是可见的） 局部变量：在类的方法中定义，在方法中临时保存数据。（作用域仅限于定义它的方法） 区别： 作用域不同 两类变量同名时，局部变量的优先级更高 初始值不同：Java会给成员变量一个初始值，不会给局部变量赋予初始值 （4）构造方法：定义在Java中的一个用来初始化对象的方法。 1234//定义格式修饰符 类名 (参数列表) &#123; …&#125; 使用new+构造方法 创建一个新的对象。 名称与类名相同且没有返回值。 当没有指定构造方法时，系统会自动添加无参的构造方法。 当有指定构造方法时，无论是有参、无参的构造方法，都不会自动添加无参的构造方法。 构造方法可重载：方法名相同，但参数不同，调用时会自动根据不同的参数选择相应的方法。 构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值（在构造函数中增加判断）。 （5）static静态变量（也称类成员） 它属于整个类所有，而不是某个对象所有，被类的所有对象所共享。 静态成员可使用类名直接访问，也可以使用对象名进行访问。 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收。 （6）static静态方法（也称类方法） 静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。 如果系统在静态方法中调用非静态变量，可通过创建类的对象，然后通过对象来访问非静态变量。 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。 （7）初始化块 123456789//1.普通初始化块&#123; xxx = xxx;&#125;//2.静态初始化块static &#123; xxx = xxx;&#125; 1***执行顺序：静态初始化块最先被执行--&gt;普通初始化块--&gt;构造方法 1//面向对象共有三个特征:封装,继承,多态 封装（1）概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法类实现对隐藏信息的操作和访问。 （2）好处：只能同规定的方法访问数据，隐藏类的实现细节，方便修改和实现，提高了代码的复用性以及安全性。 1//例如: Arrays.sort(arr);//完成排序 sort方法封装了排序的算法 （3）实现步骤 修改属性的可见性：设为private 创建getter/setter方法：用于属性的读写 在getter/setter方法中加入属性控制语句：对属性值的合法性进行判断 （4）Java中的包 作用：管理Java文件，解决同名文件的冲突 必须放在Java源程序的第一行，包名间用”.”号隔开 包的使用：可以通过import关键字在某个文件中使用其它文件中的类，Java包的命名是全小写字母 （5）Java中的访问修饰符：可以修饰属性和方法的访问范围 private：只能在本类中访问和使用。 default(默认)：能在本类和同包中访问和使用。 protected：能在本类、同包、子类中使用。 public：在本类、同包、子类、其它类中使用。 （6）Java中this关键字 1234567//代表当前对象,即本类对象的引用//this是在方法中使用的,哪个对象调用了该方法,this就代表调用该方法的对象引用//this什么时候存在的?当创建对象的时候,this存在的//this的作用:用来区别同名的成员变量与局部变量(this.成员变量)this.属性：操作当前对象的属性this.方法：调用当前对象的方法 （7）内部类：定义在另外一个类里面的类。 作用： 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。 内部类的方法可以直接访问外部类的所有数据，包括私有的数据。 内部类所实现的功能使用外部类同样可以实现，只是有时候使用内部类更方便。 分类：成员内部类，静态内部类，方法内部类，匿名内部类。 （8）成员内部类(也称普通内部类) 内部类定义在外部类内部，相当于外部类的一个成员变量的位置，内部类可以使用任意访问控制符。 内部类中的方法可以直接访问外部类中的数据，而不受访问控制符的影响。 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象。 1//即： 内部类 对象名 = 外部类对象.new 内部类() 外部类不能直接使用内部类的成员和方法，创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可使用：外部类.this.对象名 （9）静态内部类(static修饰的内部类) 静态内部类不能直接访问外部类的非静态成员，但可通过”new 外部类().成员”的方式访问 如果外部类的静态成员与内部类的成员名称相同，可通过”类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过”成员名” 直接调用。 创建静态内部类的对象时，不需要外部类的对象，可以直接创建：内部类 对象名 = new 内部类(); （10）方法内部类 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。 注意：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制修饰符和static修饰符。 继承概念： ​ 指在一个现有类的基础上去构建一个新的类,构建出来的新类被称作子类,现有类被称作父类,子类会自动拥有父类所有的非私有属性和方法。 继承的优点： 提高代码复用性 父类的属性方法可以用于子类 利于程序的设计，使设计应用程序变得简单 易于扩展 继承的缺点： 继承是侵入性的，只要继承，就必须拥有父类的所有属性和方法 降低了代码的灵活性 增强了耦合性 打破了封装性 （1）继承时类与类的一种关系，是一种”is a”的关系 （2）Java中的继承时单继承，只有一个父类 （3）class 子类 extends 父类 （4）方法的重写 子类可重写从父类继承的方法，当调用方法时会优先调用子类的方法。 返回值类型、方法名、参数类型及个数 都要与父类继承的方法相同，才叫方法的重写。 （5）继承的初始化顺序 初始化父类再初始化子类 属性的初始化在构造方法之前执行。 父类的属性初始化–&gt;父类的构造函数–&gt;子类的属性初始化–&gt;子类的构造函数 （6）final 可修饰类、方法、属性和变量 final修饰类，则该类不允许被继承 final修饰方法，则该方法不允许被覆盖(重写) final修饰属性，则该类的属性不会进行隐式初始化（类的初始化属性必须有值）或在构造方法中赋值（只能任选其一） final修饰变量，则该变量的值只能赋一次值，即变为常量 （7）super关键字 在对象的内部使用，可以代表父类，指的是父类的存储空间(理解为父类的引用)。 12345678910111213141516171819202122232425262728293031//调用父类的成员变量:super.成员变量;//调用父类的构造方法:super(参数);//调用方法的成员方法:super.成员方法();**在创建子类对象时,父类的构造方法会先执行,因为子类中所有构造方法的第一行有默认的隐式super();语句。//调用本类中的构造方法this(实参列表);//调用父类中的空参数构造方法super();//调用父类中的有参数构造方法super(实参列表);//当在方法中出现了局部变量和成员变量同名的时候,可以在成员变量名前面加上this.来区别成员变量和局部变量class Person &#123; private int age; public void setAge(int age) &#123; this.age = age; &#125;&#125;//当子父类中出现了同名成员变量时,在子类中若要访问父类中的成员变量,必须使用关键字super来完成。super用来表示当前对象中包含的父类对象空间的引用//在子类中,访问父类中的成员变量格式:super.父类中的成员变量System.out.println(“Fu num=”+super.num);//访问子类中的num2System.out.println(“Zi num2=”+this.num);//在子类中,访问父类中的成员方法格式:super.父类中的成员方法(); （8）Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另一个类，那么这个类默认继承Object类。 多态 继承是多态实现的基础，理解为同一种物质的多种形态。 使用前提：有继承或者实现关系 好处：提高了程序的扩展性 弊端：不能访问子类特有功能 1234567891011//eg：abstract class Fu &#123; public abstract void method();&#125;class Zi extends Fu &#123; public void method()&#123; System.out.println(“重写父类抽象方法”); &#125;&#125;//类的多态使用Fu fu= new Zi(); （1）引用多态：父类的引用可以指向本类的对象/父类的引用可以指向子类的对象。 （2）方法多态：创建本类对象时，调用的方法为本类方法/创建子类对象时，调用的方法为子类重写的方法或继承的方法。 （3）引用类型转换 向上类型转换：隐式/自动类型转换，小类型到大类型的转换。（无风险） 向下类型转换：强制类型转换，是大类型到小类型。（有风险） （4）抽象类 应用场景：在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 限制规定子类必须实现某些方法，但不关注实现细节。 abstract定义抽象类 abstract定义抽象方法，只有声明，不需要实现 包含抽象方法的类是抽象类 抽象类中可以包含普通的方法，也可以没有抽象方法 抽象类不能直接创建，可以定义引用变量 （5）接口 接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。 类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。 接口定义的基本语法： 1234567[修饰符] interface 接口名 [extends 父接口1, 父接口2]&#123; 1-n常量定义... 1-n抽象方法的定义....&#125; 1234567891011//接口的多态interface Fu &#123; public abstract void method();&#125;class Zi implements Fu &#123; public void method()&#123; System.out.println(“重写接口抽象方法”); &#125;&#125;//接口的多态使用Fu fu = new Zi() Java中一个类只能有一个父类，不够灵活，可通过实现多个接口增加灵活性。 接口中属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上。 接口中方法只能是抽象方法，系统会自动添加public abstract 抽象类和接口的区别（表格来源：http://www.importnew.com/12399.html） （6）UML 概念：统一建模语言或标准建模语言，支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。 常用的UML图: 用例图：能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求信息。 序列图：用于安置交互发生的一系列顺序，显示对象之间的这些交互。 类图：UML类图、业务逻辑和所有支持结构被用于定义全部的代码结构。]]></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>继承</tag>
        <tag>封装</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Arrays.asList()抛出UnsupportOperationException异常]]></title>
    <url>%2F2017%2F03%2F20%2F%E6%B5%85%E8%B0%88Arrays.asList()%E6%8A%9B%E5%87%BAUnsupportOperationException%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[初学数组常见的坑之一，执行Arrays.asList()时抛出UnsupportOperationException异常 前言： 写数组那篇文章不禁想起了以前做呆莫的时候遇到一个小坑，是什么呢？就是万恶的基础知识不是很牢（cai）固（ji）！操作数组与集合之间相互转化时报了一个 UnsupportOperationException 异常。 现场极简还原： 12345678String array[] = &#123;"test data-string"&#125;;List array2list = Arrays.asList(array);array2list.add("test data-list");//执行以上代码就会抛出 UnsupportOperationException 异常。异常是第三行导致的。Exception in thread "main" java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108)..... 才开始学习的时候，头发都掉了整整一根，这是尼玛何等卧槽。。。但还是没有想出来为啥子，最后还是机智的琢（bai）磨（du）出来了，先看AIP: 12345678910public static &lt;T&gt; List&lt;T&gt; asList(T... a)返回一个受指定数组支持的固定大小的列表。（对返回列表的更改会“直接写”到数组。）此方法同 Collection.toArray() 一起，充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。返回的列表是可序列化的，并且实现了 RandomAccess。此方法还提供了一个创建固定长度的列表的便捷方法，该列表被初始化为包含多个元素： List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly"); 参数：a - 支持列表的数组。返回：指定数组的列表视图。 在操作数组执行Arrays.asList()调用add()、remove()…时出现 java.lang.UnsupportedOperationException异常。 Arrays.asList() 返回定长的 List，不支持 add 和 remove 操作。 Arrays.asList() 返回java.util.Arrays$ArrayList， 而不是ArrayList。返回的对象是一个Arrays内部类,并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 Arrays$ArrayList和ArrayList都是继承AbstractList，remove，add等 method在AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。 ArrayList override这些method来对list进行操作，但是Arrays$ArrayList没有override remove()，add()等，所以throw UnsupportedOperationException。 那有解决办法不？这不废话么！ 一解：老老实实的遍历数组，将数组的每个元素添加到集合中。不足于会降低程序执行效率。 二解：使用了Arrays.asList()方法后将得到的集合再进行强转成集合类型。 12345678String [] array = &#123;"test data-string"&#125;;List&lt;String&gt; array2list = Arrays.asList(array);List&lt;String&gt; arrList = new ArrayList&lt;String&gt;(array2list);arrList.add("hello"); System.out.println(arrList);//[test data-string, hello] 还有其他解决方案，在此不再赘述。]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array/数组]]></title>
    <url>%2F2017%2F03%2F20%2FArray%2F</url>
    <content type="text"><![CDATA[所谓数组，是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。这些无序排列的同类数据元素的集合称为数组。 （在此不考虑三维数组，重点理解掌握数组在内存中的地址引用）1.数组的概念：​ 数组就是存储数据长度固定的容器，且多个数据的数据类型一致。1.1各个维度的数组模型（图片来源网络，具体出处未知） 一维数组数组定义： 123456789/* 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [] : 表示数组。 数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 new：关键字，创建数组使用的关键字。 数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 [长度]：数组的长度，表示数组容器中可以存储多少个元素。 注意：数组有定长特性，长度一旦指定，不可更改*/ 1234567891011121314//方式一：//数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];//exp：int [] array = new int[10];//方式二：//数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;//exp：int [] array = new int[]&#123;1,2,3&#125;;//方式三://数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;//exp：int [] array = &#123;1,2,3&#125;; 二维数组数组定义： 12345//语法一：数据类型[][] 数组名 = new int[二维数组的长度][一维数组的长度];//语法二：数据类型[][] 数组名 = new int[二维数组的长度][];(此种方式定义的一维数组需要另外分配长度，其长度可以不相同)//语法三：数据类型[][] 数组名 = new int[][]&#123;&#123;初始化数据&#125;,&#123;初始化数据&#125;&#125;;(每一对花括号是一个一维数组，使用逗号分割。此种方式定义的一维数组的长度可以不相同) 1234567891011121314151617181920212223242526272829303132333435//二位数组的创建方式一@Testpublic void test_08()&#123; int[][] arr = new int[3][5]; //输出二位数组的长度 System.out.println(arr.length); //输出第一个一维数组的长度 System.out.println(arr[0].length);&#125;//二位数组的创建方式二@Testpublic void test_09()&#123; int[][] arr = new int[3][]; arr[0] = new int[5]; //给第一个一维数组分配大小 arr[1] = new int[6]; //给第二个一维数组分配大小 //输出二位数组的长度 System.out.println(arr.length); //输出第一个一维数组的长度 System.out.println(arr[0].length); //输出第二个一维数组的长度 System.out.println(arr[1].length);&#125;//二位数组的创建方式三@Testpublic void test_10()&#123; int[][] arr = new int[][]&#123;&#123;10,11,12&#125;,&#123;10,11,12,13&#125;&#125;; //输出二位数组的长度 System.out.println(arr.length); //输出第一个一维数组的长度 System.out.println(arr[0].length); //输出第二个一维数组的长度 System.out.println(arr[1].length);&#125; 索引每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。 3.1通过索引访问一位数组： 12//数组名[索引值]array[1] 3.2通过索引访问二维数组： 12345678//数组名[二维数组的索引][一维数组的索引]//访问数组中的元素@Testpublic void test_11()&#123; int[][] arr = new int[][]&#123;&#123;10,20&#125;,&#123;50,66&#125;&#125;; //输出第二个一维数组中的第一个元素 System.out.println(arr[1][0]);&#125; 数组长度属性​ 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的 长度，语句为： 数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数 组的最大索引值为 数组名.length-1 。 数组遍历5.1一维数组的遍历： 12345678910111213141516171819//for循环遍历数组@Testpublic void test_05()&#123; int[] arr = &#123;1,2,3,4,5,6&#125;; for(int i= 0; i &lt; arr.length; i++)&#123; System.out.println(arr[i]); &#125;&#125;//while循环遍历数组@Testpublic void test_06()&#123; int[] arr = &#123;1,2,3,4,5,6&#125;; int i = 0; while(i &lt; arr.length)&#123; System.out.println(arr[i]); i++; &#125;&#125; 5.2二维数组的遍历： 1234567891011121314151617181920212223242526272829303132333435//二位数组的创建方式一@Testpublic void test_08()&#123; int[][] arr = new int[3][5]; //输出二位数组的长度 System.out.println(arr.length); //输出第一个一维数组的长度 System.out.println(arr[0].length);&#125;//二位数组的创建方式二@Testpublic void test_09()&#123; int[][] arr = new int[3][]; arr[0] = new int[5]; //给第一个一维数组分配大小 arr[1] = new int[6]; //给第二个一维数组分配大小 //输出二位数组的长度 System.out.println(arr.length); //输出第一个一维数组的长度 System.out.println(arr[0].length); //输出第二个一维数组的长度 System.out.println(arr[1].length);&#125;//二位数组的创建方式三@Testpublic void test_10()&#123; int[][] arr = new int[][]&#123;&#123;10,11,12&#125;,&#123;10,11,12,13&#125;&#125;; //输出二位数组的长度 System.out.println(arr.length); //输出第一个一维数组的长度 System.out.println(arr[0].length); //输出第二个一维数组的长度 System.out.println(arr[1].length);&#125; 常用操作（方法） 方法 描述 concat() 连接两个或更多的数组，并返回结果。 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中。 every() 检测数值元素的每个元素是否都符合条件。 fill() 使用一个固定值来填充数组。 filter() 检测数值元素，并返回符合条件所有元素的数组。 find() 返回符合传入测试（函数）条件的数组元素。 findIndex() 返回符合传入测试（函数）条件的数组元素索引。 forEach() 数组每个元素都执行一次回调函数。 indexOf() 搜索数组中的元素，并返回它所在的位置。 join() 把数组的所有元素放入一个字符串。 lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 map() 通过指定函数处理数组的每个元素，并返回处理后的数组。 pop() 删除数组的最后一个元素并返回删除的元素。 push() 向数组的末尾添加一个或更多元素，并返回新的长度。 reduce() 将数组元素计算为一个值（从左到右）。 reduceRight() 将数组元素计算为一个值（从右到左）。 reverse() 反转数组的元素顺序。 shift() 删除并返回数组的第一个元素。 slice() 选取数组的的一部分，并返回一个新数组。 some() 检测数组元素中是否有元素符合指定条件。 sort() 对数组的元素进行排序。 splice() 从数组中添加或删除元素。 toString() 把数组转换为字符串，并返回结果。 unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 valueOf() 返回数组对象的原始值。 6.1Arrays 类 1//java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 123456789101112131415161718public static int binarySearch(Object[] a, Object key)//用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。public static boolean equals(long[] a, long[] a2)//如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。public static void fill(int[] a, int val)//将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。public static void sort(Object[] a)//对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。（也可用后续的冒泡排序）Arrays.asList//使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportOperationException异常//说明：asList的返回对象是一个Arrays内部类,并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。toString//将数组转成字符串 6.2ArrayUtils类（更多具体方法查阅网络） 6.2.1反转数组 123int[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;ArrayUtils.reverse(intArray);//[5, 4, 3, 2, 1] 6.2.2移除数组中的元素 12int[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;int[] removed = ArrayUtils.removeElement(intArray, 3);//create a new array 6.2.3合并数组 1234int[] intArray = &#123; 1, 2, 3, 4, 5 &#125;;int[] intArray2 = &#123; 6, 7, 8, 9, 10 &#125;;// Apache Commons Lang libraryint[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2); 6.3判断数组是否包含某一个值（将数组转成集合，再使用集合的contains()方法进行判断） 1234String[] stringArray = &#123; "a", "b", "c", "d", "e" &#125;;boolean b = Arrays.asList(stringArray).contains("a");//也可以用Arrays.toString(str).contains进行判断，先将数组转成字符串，再用字符串的contains()方法进行判断 6.4求数组中最大最小值 假设下标为0的元素是最大值，遍历数组，依次跟max进行比较，如果有元素比这个max还大，则把这个值赋给max。最小值同样 1234567891011int[] arr=&#123;23,45,234,576,34,87,34,12,67&#125;; int max=arr[0]; int min=arr[0]; for(int i=0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;max)&#123; max=arr[i]; &#125; if(arr[i]&lt;min)&#123; min=arr[i]; &#125; &#125; 6.5对数组进行排序（冒泡排序）（与Arrays.sort()方法排序效果一样） 12345678910111213141516int[] arr=&#123;10,3,8,1,6&#125;; //外层循环控制比较轮数 for(int i=0;i&lt;arr.length-1;i++)&#123; //内层循环控制每轮比较次数 for(int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; //遍历数组 for(int i=0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125; 数组 深/浅 拷贝（克隆）将arr拷贝到brr浅拷贝： 123int[]arr=&#123;1,3,5,6,9,5&#125;; brr=arr; brr[2]=20;//new arr[2]也等与20 这种拷贝只是将arr所表示的数组在栈中的地址代码拷贝到了brr中，brr所引用的数组与arr其实就是同一个。因此叫它浅拷贝。 深拷贝：1.利用for循环结构,逐个将数组arr中的值赋给已经进行了空间开辟的数组brr 123456int[]arr=&#123;1,3,5,7,8,0&#125;; int[]brr=new int[arr.length]; for(int i=o;i&lt;arr.length;i++)&#123; brr[i]=arr[i]; &#125; brr[2]=30;//此时arr[2]=5 2.利用Arrays类中的copyOf方法 1234//arr中所有的元素均被拷贝到brr中，第二个参数便是新数组的长度 int[]brr=Arrays.copyOf(arr,arr.length); //该方法也可用来增加数组的长度 brr=Arrays.copyOf(arr,2*arr.length); 3.用System类的arraycopy方法进行拷贝 123//System.arraycopy(from,fromIndex,to,toIndex,count);//拷贝从arr的0索引开始到brr的0索引开始，一共拷贝arr.length个元素System.arraycopy(arr,0,brr,0,arr.length);]]></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>数组</tag>
        <tag>一维数组</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String/字符串]]></title>
    <url>%2F2017%2F03%2F19%2FString%2F</url>
    <content type="text"><![CDATA[java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻 译为大写或小写的所有字符的字符串的副本。 特点：字符串的值在创建后不能被更改（字符串不变）。 创建 public String()：初始化新创建的 String对象，以使其表示空字符序列。 public String(char[] value)：通过当前参数中的字符数组来构造新的String。 public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新String。 1234567891011//有三个构造方法//无参构造 String str = new String（）； // 通过字符数组构造 char chars[] = &#123;'a', 'b', 'c'&#125;; String str2 = new String(chars); // 通过字节数组构造 byte bytes[] = &#123; 97, 98, 99 &#125;; String str3 = new String(bytes); 常用方法（操作）判断 public boolean equals (Object anObject)：将此字符串与指定对象进行比较。 public boolean equalsIgnoreCase (String anotherString)：将此字符串与指定对象进行比较，忽略大小 123456789101112131415//egpublic class String_Demo01 &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = "hello"; String s2 = "hello"; String s3 = "HELLO"; //boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s1.equals(s2)); // true System.out.println(s1.equals(s3)); // false System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); //boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); // true System.out.println(s1.equalsIgnoreCase(s3)); // true System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); 获取 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。 public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。 123456789101112131415161718192021222324252627282930//egpublic class String_Demo02 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = "helloworld"; // int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length()); System.out.println("‐‐‐‐‐‐‐‐"); // String concat (String str):将将指定的字符串连接到该字符串的末尾. String s = "helloworld"; String s2 = s.concat("**hello world"); System.out.println(s2);// helloworld**hello wolrd // char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println("‐‐‐‐‐‐‐‐"); // int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1 System.out.println(s.indexOf("l")); System.out.println(s.indexOf("owo")); System.out.println(s.indexOf("ak")); System.out.println("‐‐‐‐‐‐‐‐"); // String substring(int start):从start开始截取字符串到字符串结尾 System.out.println(s.substring(0)); System.out.println(s.substring(5)); System.out.println("‐‐‐‐‐‐‐‐"); // String substring(int start,int end):从start到end截取字符串。含start，不含end。 System.out.println(s.substring(0, s.length())); System.out.println(s.substring(3,8)); &#125;&#125; 转换 public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 1234567891011121314151617181920212223public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = "abcde"; // char[] toCharArray():把字符串转换为字符数组 char[] chs = s.toCharArray(); for(int x = 0; x &lt; chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); // byte[] getBytes ():把字符串转换为字节数组 byte[] bytes = s.getBytes(); for(int x = 0; x &lt; bytes.length; x++) &#123; System.out.println(bytes[x]); &#125; System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); // 替换字母swu为大写SWU String str = "swuswu"; String replace = str.replace("swu", "SWU"); System.out.println(replace); // SWUSWU System.out.println("‐‐‐‐‐‐‐‐‐‐‐"); &#125;&#125; 分割 public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 12345678910public class String_Demo03 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = "aa|bb|cc"; String[] strArray = s.split("|"); // ["aa","bb","cc"] for(int x = 0; x &lt; strArray.length; x++) &#123; System.out.println(strArray[x]); // aa bb cc &#125; &#125;&#125; 连接使用String类提供的concat() 方法 1string1.concat(string2); String类支持的方法（附菜鸟教程的String表格 :http://www.runoob.com/java/java-string.html） 具体使用参照以上用法规则 SN(序号) 方法描述 1 char charAt(int index)返回指定索引处的 char 值。 2 int compareTo(Object o)把这个字符串和另一个对象比较。 3 int compareTo(String anotherString)按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str)按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str)将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb)当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data)返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count)返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix)测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject)将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString)将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName)使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)将字符从此字符串复制到目标字符数组。 15 int hashCode()返回此字符串的哈希码。 16 int indexOf(int ch)返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex)返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex)返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex)返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str)返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length()返回此字符串的长度。 26 boolean matches(String regex)告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len)测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar)返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement)使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex)根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit)根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix)测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset)测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex)返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex)返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray()将此字符串转换为一个新的字符数组。 40 String toLowerCase()使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase()使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale)使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim()返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x)返回给定data type类型x参数的字符串表示形式。]]></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流程控制语句]]></title>
    <url>%2F2017%2F03%2F13%2F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。 流程控制顺序结构1234567//egpublic static void main(String[] args)&#123; //顺序执行，根据编写的顺序，从上到下运行 System.out.println(1); System.out.println(2); System.out.println(3);&#125; 判断语句if1234//格式if(关系表达式)｛ 语句体;｝ 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体 如果是false就不执行语句体 12345678910111213141516//egpublic static void main(String[] args)&#123; System.out.println("开始"); // 定义两个变量 int a = 10; int b = 20; //变量使用if判断 if (a == b)&#123; System.out.println("a等于b"); &#125; int c = 10; if(a == c)&#123; System.out.println("a等于c"); &#125; System.out.println("结束");｝ if…else123456//格式if(关系表达式) &#123; 语句体1;&#125;else &#123; 语句体2;&#125; 执行流程 首先判断关系表达式看其结果是true还是false 如果是true就执行语句体1 如果是false就执行语句体2 123456789101112//egpublic static void main(String[] args)&#123; // 判断给定的数据是奇数还是偶数 // 定义变量 int a = 1; if(a % 2 == 0) &#123; System.out.println("a是偶数"); &#125; else&#123; System.out.println("a是奇数"); &#125; System.out.println("结束");&#125; if..else if…else123456789101112//格式if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125;...&#125;else if (判断条件n) &#123; 执行语句n;&#125; else &#123; 执行语句n+1;&#125; 执行流程 首先判断关系表达式1看其结果是true还是false 如果是true就执行语句体1 如果是false就继续判断关系表达式2看其结果是true还是false 如果是true就执行语句体2 如果是false就继续判断关系表达式…看其结果是true还是false … 如果没有任何关系表达式为true，就执行语句体n+1。 12345678910111213141516171819//egpublic static void main(String[] args) &#123; // x和y的关系满足如下： // x&gt;=3 y = 2x + 1; //‐1&lt;=x&lt;3 y = 2x; // x&lt;=‐1 y = 2x – 1; // 根据给定的x的值，计算出y的值并输出。 // 定义变量 int x = 5; int y; if (x&gt;= 3) &#123; y = 2 * x + 1; &#125; else if (x &gt;= ‐1 &amp;&amp; x &lt; 3) &#123; y = 2 * x; &#125; else &#123; y = 2 * x ‐ 1; &#125; System.out.println("y的值是："+y);&#125; 选择语句switch12345678910111213//格式switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; break;&#125; 执行流程 首先计算出表达式的值 其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。 最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。 12345678910111213141516171819//egpublic static void main(String[] args) &#123; //定义变量，判断是星期几 int weekday = 6; //switch语句实现选择 switch(weekday) &#123; case 1: System.out.println("星期一"); break; case 2: System.out.println("星期二"); break; ... default: System.out.println("你输入的数字有误"); break; &#125;&#125;//switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。 case的穿透性在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。 123456789101112131415161718//egpublic static void main(String[] args) &#123; int i = 5; switch (i)&#123; case 0: System.out.println("执行case0"); break; case 5: System.out.println("执行case5"); case 10: System.out.println("执行case10"); default: System.out.println("执行default"); &#125;&#125;//上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会break，直接//运行完整体switch。//由于case存在穿透性，因此初学者在编写switch语句时，必须要写上break。 循环语句for1234//格式for(初始化表达式1; 布尔表达式2; 步进表达式3)&#123; 循环体4&#125; 执行流程执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。①负责完成循环变量初始化②负责判断是否满足循环条件，不满足则跳出循环③具体执行的语句④循环后，循环条件所涉及变量的变化情况 1234567891011121314151617181920212223242526272829//eg 1public static void main(String[] args) &#123; //控制台输出4次HelloWorld，不使用循环 System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("HelloWorld"); System.out.println("‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"); //用循环改进，循环3次 //定义变量从0开始，循环条件为&lt;3 for(int x = 0; x &lt; 3; x++) &#123; System.out.println("HelloWorld"+x); &#125;&#125;//eg 2 使用循环，计算1-100之间的偶数和public static void main(String[] args) &#123; //1.定义一个初始化变量,记录累加求和,初始值为0 int sum = 0; //2.利用for循环获取1‐100之间的数字 for (int i = 1; i &lt;= 100; i++) &#123; //3.判断获取的数组是奇数还是偶数 if(i % 2==0)&#123; //4.如果是偶数就累加求和 sum += i; &#125; &#125; //5.循环结束之后,打印累加结果 System.out.println("sum:"+sum);&#125; while123456//格式初始化表达式①while(布尔表达式②)&#123; 循环体③ 步进表达式④&#125; 执行流程执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。①负责完成循环变量初始化。②负责判断是否满足循环条件，不满足则跳出循环。③具体执行的语句。④循环后，循环变量的变化情况。 123456789101112131415161718192021222324252627282930//eg 1public static void main(String[] args) &#123; //while循环实现打印10次HelloWorld //定义初始化变量 int i = 1; //循环条件&lt;=10 while(i&lt;=10)&#123; System.out.println("HelloWorld"); //步进 i++; &#125;&#125;//eg 2 while循环计算1-100之间的和public static void main(String[] args) &#123; //使用while循环实现 //定义一个变量,记录累加求和 int sum = 0; //定义初始化表达式 int i = 1; //使用while循环让初始化表达式的值变化 while(i&lt;=100)&#123; //累加求和 sum += i ; //步进表达式改变变量的值 i++; &#125; //打印求和的变量 System.out.println("1‐100的和是："+sum);&#125; do…while123456//格式初始化表达式①do&#123; 循环体③ 步进表达式④&#125;while(布尔表达式②); 执行流程执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。①负责完成循环变量初始化。②负责判断是否满足循环条件，不满足则跳出循环。③具体执行的语句④循环后，循环变量的变化情况 12345678//eg public static void main(String[] args) &#123; int x=1; do &#123; System.out.println("HelloWorld"); x++; &#125;while(x&lt;=10);&#125; do…while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。这样的循环具有一定的风险性，因此初学者不建议使用do…while循环。 12345public static void main(String[] args)&#123; do&#123; System.out.println("无条件执行一次"); &#125;while(false);&#125; 循环语句的区别 for 和 while 的小区别：1.控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。2.在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。 死循环死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。例如：while(true){}。欲想结束死循环就要用到跳出语句。 嵌套循环所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总共的循环次数=外循环次数*内循环次数嵌套循环格式： 12345for(初始化表达式①; 循环条件②; 步进表达式⑦) &#123; for(初始化表达式③; 循环条件④; 步进表达式⑥) &#123; 执行语句⑤; &#125;&#125; 嵌套循环执行流程：执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥外循环一次，内循环多次。比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。 跳出语句break使用场景：终止switch或者循环 在选择结构switch语句中 在循环语句中 离开使用场景的存在是没有意义的 12345678910//egpublic static void main(String[] args) &#123; for (int i = 1; i&lt;=10; i++) &#123; //需求:打印完两次HelloWorld之后结束循环 if(i == 3)&#123; break; &#125; System.out.println("HelloWorld"+i); &#125;&#125; continue使用场景：结束本次循环，继续下一次的循环。 12345678910//egpublic static void main(String[] args) &#123; for (int i = 1; i &lt;= 10; i++) &#123; //需求:不打印第三次HelloWorld if(i == 3)&#123; continue; &#125; System.out.println("HelloWorld"+i); &#125;&#125;]]></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>流程控制语句</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java入门简介以及环境搭建(JDK安装&配置环境变量)]]></title>
    <url>%2F2017%2F03%2F13%2FJava%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(JDK%E5%AE%89%E8%A3%85%26%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)%2F</url>
    <content type="text"><![CDATA[Java语言概述：Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 Java语言发展历史 1995年Sun公司发布Java1.0版本 1997年发布Java 1.1版本 1998年发布Java 1.2版本 2000年发布Java 1.3版本 2002年发布Java 1.4版本 2004年发布Java 1.5版本 2006年发布Java 1.6版本 2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 1.7版本 2014年发布Java 1.8版本 2017年发布Java 9.0版本 Java语言主要应用在互联网程序的开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。 Java语言开发环境搭建JVM虚拟机学习开发环境之前，首先来了解一下JVM虚拟机。 Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在JVM 之上。跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 JDK与JRE： JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含JVM 和运行时所需要的核心类库 。JDK (Java Development Kit)：是Java程序开发工具包，包含JRE 和开发人员使用的工具。我们想要运行一个已有的Java程序，那么只需安装JRE 即可。我们想要开发一个全新的Java程序，那么必须安装JDK 。 12//三者关系JDK &gt; JRE &gt; JVM 安装JDK安装的文件不要有中文和空格！（本文以jdk9为例） 配置环境变量安装完JDK之后还需要配置系统的环境变量，因为程序开发中，需要用到JDK提高的工具包。 环境变量的配置直接从百度爬过来的。附上连接，我就不一一截图了。 [https://jingyan.baidu.com/article/d45ad148ba5ab169552b80d3.html]:]]></content>
      <categories>
        <category>Java程序设计</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK安装</tag>
        <tag>环境变量配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F03%2F09%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
