<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络程序设计</title>
      <link href="/2017/05/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/05/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread/多线程</title>
      <link href="/2017/05/13/Thread/"/>
      <url>/2017/05/13/Thread/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2017/04/27/%E5%8F%8D%E5%B0%84/"/>
      <url>/2017/04/27/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Reflect </tag>
            
            <tag> Class </tag>
            
            <tag> 反射机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O流</title>
      <link href="/2017/04/20/IO%E6%B5%81/"/>
      <url>/2017/04/20/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> I/O流 </tag>
            
            <tag> Reder </tag>
            
            <tag> Writer </tag>
            
            <tag> InputStream </tag>
            
            <tag> OutputStream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架(二)-HashMap底层实现原理</title>
      <link href="/2017/04/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%BA%8C)-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2017/04/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%BA%8C)-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>先来了解哈希表，什么是哈希表呢？<br>在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。 但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈 希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找 时间。</p><a id="more"></a><h3 id="HashMap的底层实现原理"><a href="#HashMap的底层实现原理" class="headerlink" title="HashMap的底层实现原理"></a>HashMap的底层实现原理</h3><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p><a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。</p><p>数组：</p><p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</p><p>链表：</p><p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。<strong>链表</strong>的特点是：寻址困难，插入和删除容易。</p><p>哈希表：</p><p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p><p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“<strong>链表的数组</strong>” ，如图：</p><p><img src="https://app.yinxiang.com/shard/s33/nl/22781464/2ed59691-d930-4b45-b5a2-1dc04d88fd64/res/023bf655-674f-496d-95d6-3c65a080eddf/SouthEast?resizeSmall&amp;width=832" alt=""></p><p><img src="https://app.yinxiang.com/shard/s33/nl/22781464/2ed59691-d930-4b45-b5a2-1dc04d88fd64/res/7a5715e9-f6fc-41cf-b019-639881d3a527/SouthEast?resizeSmall&amp;width=832" alt=""></p><p>​    从上图我们可以发现哈希表是由<strong>数组+链表</strong>组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p><p>​    HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p><p>​    首先HashMap里面实现一个静态内部类Entry，其重要的属性有 <em>key , value, next</em>，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><h4 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h4><p>既然是线性数组，为什么能随机存取？这里HashMap用了一个小<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>，大致是这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储时:</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode(); <span class="comment">// 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span></span><br><span class="line"><span class="keyword">int</span> index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值时:</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = hash % Entry[].length;</span><br><span class="line"><span class="keyword">return</span> Entry[index];</span><br></pre></td></tr></table></figure><p>1）<em>put</em></p><p>疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？</p><p>　　这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:<em>B.next = A</em>,Entry[0] = B,如果又进来C,index也等于0,那么<em>C.next = B</em>,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。<strong>也就是说数组中存储的是最后插入的元素。</strong>到这里为止，HashMap的大致实现，我们应该已经清楚了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value); <span class="comment">//null总是放在数组的第一个链表中</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">//如果key在链表中已存在，则替换为新value</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e); <span class="comment">//参数e, 是Entry.next</span></span><br><span class="line">    <span class="comment">//如果size超过threshold，则扩充table大小。再散列</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p><p>2）<em>get</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="comment">//先定位到数组元素，再遍历该元素处的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）<em>null key的存取</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//null key总是存放在Entry[]数组的第一个元素。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4）<em>确定数组index：hashcode % table.length取模</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下：</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>5）<em>table初始大小</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        .....         <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意table初始大小并不是构造函数中的initialCapacity！！</strong></p><p><strong>而是 &gt;= initialCapacity的2的n次幂！！！！</strong></p><p>——为什么这么设计呢？——</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">来看看哈希冲突（来源：https://www.cnblogs.com/chengxiao/p/6059914.html）</span><br><span class="line">哈希冲突</span><br><span class="line">　　然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，</span><br></pre></td></tr></table></figure><h4 id="解决hash冲突的办法"><a href="#解决hash冲突的办法" class="headerlink" title="解决hash冲突的办法"></a>解决hash冲突的办法</h4><ol><li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li><li>再哈希法</li><li><strong>链地址法</strong></li><li>建立一个公共溢出区</li></ol><p><a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>中hashmap的解决办法就是采用的链地址法。</p><h4 id="再散列rehash过程"><a href="#再散列rehash过程" class="headerlink" title="再散列rehash过程"></a>再散列rehash过程</h4><p>当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">     * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">     * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">     * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">     *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">     *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">     *        is irrelevant).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="comment">//重新计算index</span></span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><em>文章来源：<a href="https://www.cnblogs.com/holyshengjie/p/6500463.html" target="_blank" rel="noopener">https://www.cnblogs.com/holyshengjie/p/6500463.html</a></em></strong></p><p><strong><em>参考博文：<a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6059914.html</a></em></strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HaspMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架(一)</title>
      <link href="/2017/04/11/%E9%9B%86%E5%90%88/"/>
      <url>/2017/04/11/%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>集合是java中提供的一种容器，可以用来存储多个数据，集合类存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用（reference)。                                                                   集合类型主要有3种：set(集）、list(列表）和map(映射)。                                                                                           集合接口分为：Collection和Map，list、set实现了Collection接口。</p><a id="more"></a><p>在此多啰嗦一点，前面文章提到数组，数组与集合都是容器，那他们之间到底有什么区别呢？区别主要分一下两点（在实际开发中灵活运用，大多数使用集合）</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>来一张集合框架图（图片来源：<a href="https://liujiacai.net/blog/2015/09/01/java-collection-overview/）" target="_blank" rel="noopener">https://liujiacai.net/blog/2015/09/01/java-collection-overview/）</a></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB21HYoeVXXXXaLXXXXXXXXXXXX_!!581166664.jpeg" alt="集合框架图"></p><p>常用四个接口的区别：</p><p>1、collection:存储不唯一、无序的数据；</p><p>2、list：存储有序的、不唯一的数据；</p><p>3、set：存储无序的、唯一的数据；</p><p>4、Map：以键值对的形式存储数据，以键取值。键不能重复、值可以重复。</p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h4><p>是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用<br>的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li>public boolean add(E e) ： 把给定的对象添加到当前集合中 。</li><li>public void clear() :清空集合中所有的元素。</li><li>public boolean remove(E e) : 把给定的对象在当前集合中删除。</li><li>public boolean contains(E e) : 判断当前集合中是否包含给定的对象。</li><li>public boolean isEmpty() : 判断当前集合是否为空。</li><li>public int size() : 返回集合中元素的个数。</li><li>public Object[] toArray() : 把集合中的元素，存储到数组中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合对象</span></span><br><span class="line">        <span class="comment">// 使用多态形式</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 使用方法</span></span><br><span class="line">        <span class="comment">// 添加功能 boolean add(String s)</span></span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">        <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">        System.out.println(<span class="string">"判断 str1 是否在集合中"</span>+coll.contains(<span class="string">"str1"</span>));</span><br><span class="line">        <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">        System.out.println(<span class="string">"删除str2："</span>+coll.remove(<span class="string">"str2"</span>));</span><br><span class="line">        System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">        <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">        System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line">        <span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">        Object[] objects = coll.toArray();</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        System.out.println(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// void clear() 清空集合</span></span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line">        <span class="comment">// boolean isEmpty() 判断是否为空</span></span><br><span class="line">        System.out.println(coll.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h4><h5 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h5><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接 口 java.util.Iterator 。 Iterator 接口也是Java集合中的一员，但它 与 Collection 、 Map 接口有所不同， Collection 接口与 Map 接口主要用于存储元素， 而 Iterator 主要用于迭代访问（即遍历） Collection 中的元素，因此 Iterator 对象也 被称为迭代器。<br>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取 迭代器的方法：</p><ul><li>public Iterator iterator() : 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>迭代的概念：</p><p>即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有 元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把 集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><p>Iterator接口的常用方法如下：</p><ul><li>public E next() :返回迭代的下一个元素。 </li><li>public boolean hasNext() :如果仍有元素可以迭代，则返回 true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历 每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">// 泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">        String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h5><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p><p>首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><p>当然，迭代器在开发中基本不用，一般使用增强for，在学习阶段也是必须了解的内容。</p><h5 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h5><p>增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数<br>组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合<br>中的元素进行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 : Collection集合or数组)&#123;</span><br><span class="line"><span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进<br>行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg1</span></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="comment">//使用增强for遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg2</span></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p>List集合包括List接口以及List接口接口的所有实现类，List集合中的元素允许重复，各元素的顺序就是对象插入的顺序，类似Java数组，用户可通过使用索引来访问集合中的元素。</p><h5 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h5><p>java.util.List 接口继承自Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了List 接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>List接口特点</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、<br>22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><p>List接口中常用方法：</p><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操<br>作集合的特有方法，如下：</p><ul><li>public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。</li><li>public E get(int index) :返回集合中指定位置的元素。</li><li>public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li>public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List的子类</p><h5 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h5><p>java.util.ArrayList 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList 是最常用的集合。</p><h5 id="LinkedList集合："><a href="#LinkedList集合：" class="headerlink" title="LinkedList集合："></a>LinkedList集合：</h5><p>java.util.LinkedList 集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDgy1fz5f1r4fuzj30vb0f8tak.jpg" alt="LinkedList "></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方<br>法我们作为了解即可：</p><ul><li>public void addFirst(E e) :将指定元素插入此列表的开头。</li><li>public void addLast(E e) :将指定元素添加到此列表的结尾。</li><li>public E getFirst() :返回此列表的第一个元素。</li><li>public E getLast() :返回此列表的最后一个元素。</li><li>public E removeFirst() :移除并返回此列表的第一个元素。</li><li>public E removeLast() :移除并返回此列表的最后一个元素。</li><li>public E pop() :从此列表所表示的堆栈处弹出一个元素。</li><li>public void push(E e) :将元素推入此列表所表示的堆栈。</li><li>public boolean isEmpty() ：如果列表不包含元素，则返回true。</li></ul><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>对于Vector，它是jdk1.0就留下来的，它和ArrayList是类似的，不同点就是，它是线程安全的，在多线程的环境下使用其可能有好处，但是非多线程情况下使用效率会很低。</p><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h4><p>Set集合中的对象不按特定的方式排序，只是简单的把对象加入集合中，但Set集合中不能包含重复对象，Set集合由Set接口和Set接口的实现类组成，Set接口继承了Collection接口，因此包含Collection的所有方法。</p><h5 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h5><p>java.util.Set 接口和java.util.List 接口一样，同样继承自Collection 接口，它与Collection 接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比Collection 接口更加严格了。与List 接口不同的是， Set     接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p>Set 集合有多个子类，这里我们介绍其中的java.util.HashSet 、java.util.LinkedHashSet 这两个集合。其他不常用。</p><p>java.util.HashSet 是Set 接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序<br>不一致)。java.util.HashSet 底层的实现其实是一个java.util.HashMap 支持，后面会将HashMap。</p><p>HashSet 是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于： hashCode 与equals 方法。</p><h5 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a>HashSet集合存储数据的结构（哈希表）</h5><p>什么是哈希表呢？<br>在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。<br>但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈<br>希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找<br>时间。<br>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p><p>（图片来源：<a href="https://blog.csdn.net/login_sonata/article/details/76598675）" target="_blank" rel="noopener">https://blog.csdn.net/login_sonata/article/details/76598675）</a></p><p><img src="https://img-blog.csdn.net/20170803204952538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG9naW5fc29uYXRh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>为了方便理解，附HashSet存储原理图（即HashMap底层）（图片来源网络，具体不详）</p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz5focw9yyj30sp0qw0xg.jpg" alt="hashmap底层"></p><h5 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h5><p>LinkedHashSet类也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序。与HashSet相比，特点：</p><ol><li>对集合迭代时，按增加顺序返回元素。</li><li>性能略低于HashSet，因为需要维护元素的插入顺序。但迭代访问元素时会有好性能，因为它采用链表维护内部顺序。</li></ol><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h4><p>Map集合提供的是key到value的映射，Map中不能包含相同的key，每个key只能映射一个value，key决定了存储对象在映射中的存储位置，但不是key对象本身决定的，而是由一种“散列技术”进行处理，产生一个散列码的整数值，散列码通常用作一个偏移量，该偏移量对应分配给映射的内存区域的起始位置，从而确定储存对象在映射中的储存位置，Map集合包括Map接口以及接口的所有实现类。</p><p>Map常用子类：</p><ul><li><p>HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需 要重写键的hashCode()方法、equals()方法。 </p></li><li><p>LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链 表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。</p></li></ul><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h5><p>Map接口常用方法：</p><ul><li>public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。</li><li>public V remove(Object key) : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li>public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</li><li>public Set<k> keySet() : 获取Map集合中所有的键，存储到Set集合中。</k></li><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">"s2"</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"s1"</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">"s3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h5><p>键找值方式：即通过元素中的键，获取键所对应的值<br>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示: keyset()</li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示: get(K key)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//获取所有的键 获取键集</span></span><br><span class="line">            Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="comment">//key 就是键</span></span><br><span class="line">        <span class="comment">//获取对应值</span></span><br><span class="line">        String value = map.get(key);</span><br><span class="line">        System.out.println(key+<span class="string">"的value是："</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h5><p>Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map 中是一一对应关系，这一对对象又称做Map 中的一个Entry(项) 。Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。</p><p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li>public K getKey() ：获取Entry对象中的键。</li><li>public V getValue() ：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h5 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h5><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>分析步骤：</p><ol><li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示: entrySet() 。</li><li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li>通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示: getkey() getValue()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象 entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        System.out.println(key+<span class="string">"的value是:"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，要保证有序，还要速度快就要使用HashMap下面的一个子类LinkedHashMap，是链表和哈希表组合的一个数据存储结构。完美解决以上问题</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> List </tag>
            
            <tag> Map </tag>
            
            <tag> Set </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象之三大特性</title>
      <link href="/2017/03/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2017/03/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Java 语言重要思想即面向对象，一切皆对象，且具有三大特征：继承、封装 、多态。面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。可以将复杂的业务逻辑简单化，增强代码的复用性，亦而比较符合人们的思考习惯。</p><a id="more"></a><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>（1）类：类是对某一类事物的抽象描述，是对象的模板，确定对象将会拥有的特征(属性)和行为(方法)。</p><p>​      特点：类是具有相同属性和方法的一组对象的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line"><span class="comment">//可编写0至n个属性</span></span><br><span class="line">数据类型 变量名<span class="number">1</span>;</span><br><span class="line">数据类型 变量名<span class="number">2</span>;</span><br><span class="line"><span class="comment">//可编写0至n个方法</span></span><br><span class="line">修饰符 返回值类型 方法名(参数)&#123;</span><br><span class="line">执行语句;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）对象：用于描述现实中的个体,它是类的实例。</p><p>创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名()</span><br><span class="line"></span><br><span class="line">对象.属性   /   对象.方法名()</span><br></pre></td></tr></table></figure><p>（3）成员变量与局部变量</p><p>成员变量：在类中定义，用来描述对象将要有什么。（作用域在整个类内部都是可见的）</p><p>局部变量：在类的方法中定义，在方法中临时保存数据。（作用域仅限于定义它的方法）</p><p>区别：</p><ul><li>作用域不同</li><li>两类变量同名时，局部变量的优先级更高</li><li>初始值不同：Java会给成员变量一个初始值，不会给局部变量赋予初始值</li></ul><p>（4）构造方法：定义在Java中的一个用来初始化对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义格式</span></span><br><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用new+构造方法 创建一个新的对象。</li><li>名称与类名相同且没有返回值。</li><li>当没有指定构造方法时，系统会自动添加无参的构造方法。</li><li>当有指定构造方法时，无论是有参、无参的构造方法，都不会自动添加无参的构造方法。</li><li>构造方法可重载：方法名相同，但参数不同，调用时会自动根据不同的参数选择相应的方法。</li><li>构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值（在构造函数中增加判断）。</li></ul><p>（5）static静态变量（也称类成员）</p><ul><li>它属于整个类所有，而不是某个对象所有，被类的所有对象所共享。</li><li>静态成员可使用类名直接访问，也可以使用对象名进行访问。</li><li>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收。</li></ul><p>（6）static静态方法（也称类方法）</p><ul><li>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。</li><li>如果系统在静态方法中调用非静态变量，可通过创建类的对象，然后通过对象来访问非静态变量。</li><li>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。</li><li>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。</li></ul><p>（7）初始化块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.普通初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">xxx = xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">xxx = xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***执行顺序：静态初始化块最先被执行--&gt;普通初始化块--&gt;构造方法</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面向对象共有三个特征:封装,继承,多态</span></span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>（1）概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法类实现对隐藏信息的操作和访问。</p><p>（2）好处：只能同规定的方法访问数据，隐藏类的实现细节，方便修改和实现，提高了代码的复用性以及安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如: Arrays.sort(arr);//完成排序 sort方法封装了排序的算法</span></span><br></pre></td></tr></table></figure><p>（3）实现步骤</p><ol><li>修改属性的可见性：设为private</li><li>创建getter/setter方法：用于属性的读写</li><li>在getter/setter方法中加入属性控制语句：对属性值的合法性进行判断</li></ol><p>（4）Java中的包</p><ul><li>作用：管理Java文件，解决同名文件的冲突</li><li>必须放在Java源程序的第一行，包名间用”.”号隔开</li><li>包的使用：可以通过import关键字在某个文件中使用其它文件中的类，Java包的命名是全小写字母</li></ul><p>（5）Java中的访问修饰符：可以修饰属性和方法的访问范围</p><ul><li>private：只能在本类中访问和使用。</li><li>default(默认)：能在本类和同包中访问和使用。</li><li>protected：能在本类、同包、子类中使用。</li><li>public：在本类、同包、子类、其它类中使用。</li></ul><p>（6）Java中this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表当前对象,即本类对象的引用</span></span><br><span class="line"><span class="comment">//this是在方法中使用的,哪个对象调用了该方法,this就代表调用该方法的对象引用</span></span><br><span class="line"><span class="comment">//this什么时候存在的?当创建对象的时候,this存在的</span></span><br><span class="line"><span class="comment">//this的作用:用来区别同名的成员变量与局部变量(this.成员变量)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.属性：操作当前对象的属性</span><br><span class="line"><span class="keyword">this</span>.方法：调用当前对象的方法</span><br></pre></td></tr></table></figure><p>（7）内部类：定义在另外一个类里面的类。</p><p>作用：</p><ul><li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据。</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时候使用内部类更方便。</li></ul><p>分类：成员内部类，静态内部类，方法内部类，匿名内部类。</p><p>（8）成员内部类(也称普通内部类)</p><ul><li>内部类定义在外部类内部，相当于外部类的一个成员变量的位置，内部类可以使用任意访问控制符。</li><li>内部类中的方法可以直接访问外部类中的数据，而不受访问控制符的影响。</li><li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即： 内部类 对象名 = 外部类对象.new 内部类()</span></span><br></pre></td></tr></table></figure><ul><li>外部类不能直接使用内部类的成员和方法，创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</li><li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可使用：外部类.this.对象名</li></ul><p>（9）静态内部类(static修饰的内部类)</p><ul><li>静态内部类不能直接访问外部类的非静态成员，但可通过”new 外部类().成员”的方式访问</li><li>如果外部类的静态成员与内部类的成员名称相同，可通过”类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过”成员名” 直接调用。</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建：内部类 对象名 = new 内部类();</li></ul><p>（10）方法内部类</p><p>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</p><p>注意：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制修饰符和static修饰符。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>概念：</p><p>​    指在一个现有类的基础上去构建一个新的类,构建出来的新类被称作子类,现有类被称作父类,子类会自动拥有父类所有的非私有属性和方法。</p><p>继承的优点：</p><ul><li>提高代码复用性</li><li>父类的属性方法可以用于子类</li><li>利于程序的设计，使设计应用程序变得简单</li><li>易于扩展</li></ul><p>继承的缺点：</p><ul><li>继承是侵入性的，只要继承，就必须拥有父类的所有属性和方法</li><li>降低了代码的灵活性</li><li>增强了耦合性</li><li>打破了封装性</li></ul><p>（1）继承时类与类的一种关系，是一种”is a”的关系</p><p>（2）Java中的继承时单继承，只有一个父类</p><p>（3）class 子类 extends 父类</p><p>（4）方法的重写</p><ul><li>子类可重写从父类继承的方法，当调用方法时会优先调用子类的方法。</li><li>返回值类型、方法名、参数类型及个数 都要与父类继承的方法相同，才叫方法的重写。</li></ul><p>（5）继承的初始化顺序</p><ul><li>初始化父类再初始化子类</li><li>属性的初始化在构造方法之前执行。</li><li>父类的属性初始化–&gt;父类的构造函数–&gt;子类的属性初始化–&gt;子类的构造函数</li></ul><p>（6）final</p><p>可修饰类、方法、属性和变量</p><ul><li>final修饰类，则该类不允许被继承</li><li>final修饰方法，则该方法不允许被覆盖(重写)</li><li>final修饰属性，则该类的属性不会进行隐式初始化（类的初始化属性必须有值）或在构造方法中赋值（只能任选其一）</li><li>final修饰变量，则该变量的值只能赋一次值，即变为常量</li></ul><p>（7）super关键字</p><p>在对象的内部使用，可以代表父类，指的是父类的存储空间(理解为父类的引用)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用父类的成员变量:</span></span><br><span class="line"><span class="keyword">super</span>.成员变量;</span><br><span class="line"><span class="comment">//调用父类的构造方法:</span></span><br><span class="line"><span class="keyword">super</span>(参数);</span><br><span class="line"><span class="comment">//调用方法的成员方法:</span></span><br><span class="line"><span class="keyword">super</span>.成员方法();</span><br><span class="line">**在创建子类对象时,父类的构造方法会先执行,因为子类中所有构造方法的第一行有默认的隐式<span class="keyword">super</span>();语句。</span><br><span class="line"><span class="comment">//调用本类中的构造方法</span></span><br><span class="line"><span class="keyword">this</span>(实参列表);</span><br><span class="line"><span class="comment">//调用父类中的空参数构造方法</span></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="comment">//调用父类中的有参数构造方法</span></span><br><span class="line"><span class="keyword">super</span>(实参列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当在方法中出现了局部变量和成员变量同名的时候,可以在成员变量名前面加上this.来区别成员变量和局部变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子父类中出现了同名成员变量时,在子类中若要访问父类中的成员变量,必须使用关键字super来完成。super用来表示当前对象中包含的父类对象空间的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在子类中,访问父类中的成员变量格式:</span></span><br><span class="line"><span class="keyword">super</span>.父类中的成员变量</span><br><span class="line">System.out.println(“Fu num=”+<span class="keyword">super</span>.num);</span><br><span class="line"><span class="comment">//访问子类中的num2</span></span><br><span class="line">System.out.println(“Zi num2=”+<span class="keyword">this</span>.num);</span><br><span class="line"><span class="comment">//在子类中,访问父类中的成员方法格式:</span></span><br><span class="line"><span class="keyword">super</span>.父类中的成员方法();</span><br></pre></td></tr></table></figure><p>（8）Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另一个类，那么这个类默认继承Object类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>继承是多态实现的基础，理解为同一种物质的多种形态。</p></li><li><p>使用前提：有继承或者实现关系</p></li><li><p>好处：提高了程序的扩展性</p></li><li><p>弊端：不能访问子类特有功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg：</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(“重写父类抽象方法”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的多态使用</span></span><br><span class="line">Fu fu= <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li></ul><p>（1）引用多态：父类的引用可以指向本类的对象/父类的引用可以指向子类的对象。</p><p>（2）方法多态：创建本类对象时，调用的方法为本类方法/创建子类对象时，调用的方法为子类重写的方法或继承的方法。</p><p>（3）引用类型转换</p><ul><li>向上类型转换：隐式/自动类型转换，小类型到大类型的转换。（无风险）</li><li>向下类型转换：强制类型转换，是大类型到小类型。（有风险）</li></ul><p>（4）抽象类</p><p>应用场景：在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。</p><ul><li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。</li><li>限制规定子类必须实现某些方法，但不关注实现细节。</li><li>abstract定义抽象类</li><li>abstract定义抽象方法，只有声明，不需要实现</li><li>包含抽象方法的类是抽象类</li><li>抽象类中可以包含普通的方法，也可以没有抽象方法</li><li>抽象类不能直接创建，可以定义引用变量</li></ul><p>（5）接口</p><ul><li>接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。</li><li>类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。</li><li>接口定义的基本语法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口1, 父接口2]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span>-n常量定义...</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>-n抽象方法的定义....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的多态</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(“重写接口抽象方法”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的多态使用</span></span><br><span class="line">Fu fu = <span class="keyword">new</span> Zi()</span><br></pre></td></tr></table></figure><ul><li>Java中一个类只能有一个父类，不够灵活，可通过实现多个接口增加灵活性。</li><li>接口中属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上。</li><li>接口中方法只能是抽象方法，系统会自动添加public abstract</li></ul><p>抽象类和接口的区别（表格来源：<a href="http://www.importnew.com/12399.html）" target="_blank" rel="noopener">http://www.importnew.com/12399.html）</a></p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz4v0go92sj30lo0kdtb2.jpg" alt="抽象类和接口的区别"></p><p>（6）UML</p><p>概念：统一建模语言或标准建模语言，支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。</p><p>常用的UML图:</p><p>用例图：能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求信息。</p><p>序列图：用于安置交互发生的一系列顺序，显示对象之间的这些交互。</p><p>类图：UML类图、业务逻辑和所有支持结构被用于定义全部的代码结构。</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Arrays.asList()抛出UnsupportOperationException异常</title>
      <link href="/2017/03/20/%E6%B5%85%E8%B0%88Arrays.asList()%E6%8A%9B%E5%87%BAUnsupportOperationException%E5%BC%82%E5%B8%B8/"/>
      <url>/2017/03/20/%E6%B5%85%E8%B0%88Arrays.asList()%E6%8A%9B%E5%87%BAUnsupportOperationException%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>初学数组常见的坑之一，执行Arrays.asList()时抛出UnsupportOperationException异常</p><a id="more"></a><p>前言：</p><p>写数组那篇文章不禁想起了以前做呆莫的时候遇到一个小坑，是什么呢？就是万恶的基础知识不是很牢（cai）固（ji）！操作数组与集合之间相互转化时报了一个 UnsupportOperationException 异常。</p><p>现场极简还原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String array[] = &#123;<span class="string">"test data-string"</span>&#125;;</span><br><span class="line">List array2list = Arrays.asList(array);</span><br><span class="line">array2list.add(<span class="string">"test data-list"</span>);</span><br><span class="line"><span class="comment">//执行以上代码就会抛出 UnsupportOperationException 异常。异常是第三行导致的。</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">148</span>)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">108</span>)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>才开始学习的时候，头发都掉了整整一根，这是尼玛何等卧槽。。。但还是没有想出来为啥子，最后还是机智的琢（bai）磨（du）出来了，先看AIP:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">返回一个受指定数组支持的固定大小的列表。（对返回列表的更改会“直接写”到数组。）此方法同 Collection.<span class="title">toArray</span><span class="params">()</span> 一起，充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。返回的列表是可序列化的，并且实现了 RandomAccess。</span></span><br><span class="line"><span class="function">此方法还提供了一个创建固定长度的列表的便捷方法，该列表被初始化为包含多个元素：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">     List&lt;String&gt; stooges </span>= Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line"> </span><br><span class="line">参数：</span><br><span class="line">a - 支持列表的数组。</span><br><span class="line">返回：</span><br><span class="line">指定数组的列表视图。</span><br></pre></td></tr></table></figure><p>在操作数组执行Arrays.asList()调用add()、remove()…时出现 java.lang.UnsupportedOperationException异常。</p><p>Arrays.asList() 返回定长的 List，不支持 add 和 remove 操作。</p><p>Arrays.asList() 返回java.util.Arrays$ArrayList， 而不是ArrayList。返回的对象是一个Arrays内部类,并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><p>Arrays$ArrayList和ArrayList都是继承AbstractList，remove，add等 method在AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。</p><p>ArrayList override这些method来对list进行操作，但是Arrays$ArrayList没有override remove()，add()等，所以throw UnsupportedOperationException。</p><p>那有解决办法不？这不废话么！</p><p>一解：老老实实的遍历数组，将数组的每个元素添加到集合中。不足于会降低程序执行效率。</p><p>二解：使用了Arrays.asList()方法后将得到的集合再进行强转成集合类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String [] array = &#123;<span class="string">"test data-string"</span>&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; array2list = Arrays.asList(array);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; arrList = <span class="keyword">new</span> ArrayList&lt;String&gt;(array2list);</span><br><span class="line">arrList.add(<span class="string">"hello"</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(arrList);<span class="comment">//[test data-string, hello]</span></span><br></pre></td></tr></table></figure><p>还有其他解决方案，在此不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array/数组</title>
      <link href="/2017/03/20/Array/"/>
      <url>/2017/03/20/Array/</url>
      
        <content type="html"><![CDATA[<p>所谓数组，是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。这些无序排列的同类数据元素的集合称为数组。</p><a id="more"></a><p>（在此不考虑三维数组，重点理解掌握数组在内存中的地址引用）<br>1.数组的概念：<br>​        数组就是存储数据长度固定的容器，且多个数据的数据类型一致。<br>1.1各个维度的数组模型<br>（图片来源网络，具体出处未知）</p><p><img src="http://wx4.sinaimg.cn/mw690/0077hIeDgy1fz17tpi61oj30ji0l3whv.jpg" alt="数组地址内存图"></p><p><img src="http://wx4.sinaimg.cn/mw690/0077hIeDly1fz17yg5a4rj30jj0c4mxz.jpg" alt="java内存图"></p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>数组定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 </span></span><br><span class="line"><span class="comment">[] : 表示数组。 </span></span><br><span class="line"><span class="comment">数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 </span></span><br><span class="line"><span class="comment">new：关键字，创建数组使用的关键字。</span></span><br><span class="line"><span class="comment">数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 </span></span><br><span class="line"><span class="comment">[长度]：数组的长度，表示数组容器中可以存储多少个元素。 </span></span><br><span class="line"><span class="comment">注意：数组有定长特性，长度一旦指定，不可更改</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];</span></span><br><span class="line"><span class="comment">//exp：</span></span><br><span class="line"><span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;</span></span><br><span class="line"><span class="comment">//exp：</span></span><br><span class="line"><span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三:</span></span><br><span class="line"><span class="comment">//数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;</span></span><br><span class="line"><span class="comment">//exp：</span></span><br><span class="line"><span class="keyword">int</span> [] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>数组定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法一：数据类型[][] 数组名 = new int[二维数组的长度][一维数组的长度];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法二：数据类型[][] 数组名 = new int[二维数组的长度][];(此种方式定义的一维数组需要另外分配长度，其长度可以不相同)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法三：数据类型[][] 数组名 = new int[][]&#123;&#123;初始化数据&#125;,&#123;初始化数据&#125;&#125;;(每一对花括号是一个一维数组，使用逗号分割。此种方式定义的一维数组的长度可以不相同)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二位数组的创建方式一</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_08</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式二</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_09</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];    <span class="comment">//给第一个一维数组分配大小</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];    <span class="comment">//给第二个一维数组分配大小</span></span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式三</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_10</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h3><p>每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。</p><p>3.1通过索引访问一位数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组名[索引值]</span></span><br><span class="line">array[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>3.2通过索引访问二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组名[二维数组的索引][一维数组的索引]</span></span><br><span class="line"><span class="comment">//访问数组中的元素</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_11</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="number">50</span>,<span class="number">66</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//输出第二个一维数组中的第一个元素</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组长度属性："><a href="#数组长度属性：" class="headerlink" title="数组长度属性："></a>数组长度属性：</h3><p>​        每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的 长度，语句为： 数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数 组的最大索引值为 数组名.length-1 。</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>5.1一维数组的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环遍历数组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_05</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while循环遍历数组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_06</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr.length)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.2二维数组的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二位数组的创建方式一</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_08</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式二</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_09</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];    <span class="comment">//给第一个一维数组分配大小</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];    <span class="comment">//给第二个一维数组分配大小</span></span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式三</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_10</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用操作（方法）"><a href="#常用操作（方法）" class="headerlink" title="常用操作（方法）"></a>常用操作（方法）</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/jsref-concat-array.html" target="_blank" rel="noopener">concat()</a></td><td>连接两个或更多的数组，并返回结果。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-copywithin.html" target="_blank" rel="noopener">copyWithin()</a></td><td>从数组的指定位置拷贝元素到数组的另一个指定位置中。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-every.html" target="_blank" rel="noopener">every()</a></td><td>检测数值元素的每个元素是否都符合条件。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-fill.html" target="_blank" rel="noopener">fill()</a></td><td>使用一个固定值来填充数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-filter.html" target="_blank" rel="noopener">filter()</a></td><td>检测数值元素，并返回符合条件所有元素的数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-find.html" target="_blank" rel="noopener">find()</a></td><td>返回符合传入测试（函数）条件的数组元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-findindex.html" target="_blank" rel="noopener">findIndex()</a></td><td>返回符合传入测试（函数）条件的数组元素索引。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-foreach.html" target="_blank" rel="noopener">forEach()</a></td><td>数组每个元素都执行一次回调函数。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-indexof-array.html" target="_blank" rel="noopener">indexOf()</a></td><td>搜索数组中的元素，并返回它所在的位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-join.html" target="_blank" rel="noopener">join()</a></td><td>把数组的所有元素放入一个字符串。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-lastindexof-array.html" target="_blank" rel="noopener">lastIndexOf()</a></td><td>返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-map.html" target="_blank" rel="noopener">map()</a></td><td>通过指定函数处理数组的每个元素，并返回处理后的数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-pop.html" target="_blank" rel="noopener">pop()</a></td><td>删除数组的最后一个元素并返回删除的元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-push.html" target="_blank" rel="noopener">push()</a></td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-reduce.html" target="_blank" rel="noopener">reduce()</a></td><td>将数组元素计算为一个值（从左到右）。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-reduceright.html" target="_blank" rel="noopener">reduceRight()</a></td><td>将数组元素计算为一个值（从右到左）。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-reverse.html" target="_blank" rel="noopener">reverse()</a></td><td>反转数组的元素顺序。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-shift.html" target="_blank" rel="noopener">shift()</a></td><td>删除并返回数组的第一个元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-slice-array.html" target="_blank" rel="noopener">slice()</a></td><td>选取数组的的一部分，并返回一个新数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-some.html" target="_blank" rel="noopener">some()</a></td><td>检测数组元素中是否有元素符合指定条件。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-sort.html" target="_blank" rel="noopener">sort()</a></td><td>对数组的元素进行排序。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-splice.html" target="_blank" rel="noopener">splice()</a></td><td>从数组中添加或删除元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-tostring-array.html" target="_blank" rel="noopener">toString()</a></td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-unshift.html" target="_blank" rel="noopener">unshift()</a></td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-valueof-array.html" target="_blank" rel="noopener">valueOf()</a></td><td>返回数组对象的原始值。</td></tr></tbody></table><p>6.1Arrays 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Object[] a, Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">//用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span>[] a2)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。（也可用后续的冒泡排序）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Arrays.asList</span></span><br><span class="line"><span class="function"><span class="comment">//使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportOperationException异常</span></span></span><br><span class="line"><span class="function"><span class="comment">//说明：asList的返回对象是一个Arrays内部类,并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">toString</span></span><br><span class="line"><span class="function"><span class="comment">//将数组转成字符串</span></span></span><br></pre></td></tr></table></figure><p>6.2ArrayUtils类（更多具体方法查阅网络）</p><p>6.2.1反转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">ArrayUtils.reverse(intArray);</span><br><span class="line"><span class="comment">//[5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>6.2.2移除数组中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] removed = ArrayUtils.removeElement(intArray, <span class="number">3</span>);<span class="comment">//create a new array</span></span><br></pre></td></tr></table></figure><p>6.2.3合并数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] intArray2 = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">// Apache Commons Lang library</span></span><br><span class="line"><span class="keyword">int</span>[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);</span><br></pre></td></tr></table></figure><p>6.3判断数组是否包含某一个值（将数组转成集合，再使用集合的contains()方法进行判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span> &#125;;</span><br><span class="line"><span class="keyword">boolean</span> b = Arrays.asList(stringArray).contains(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用Arrays.toString(str).contains进行判断，先将数组转成字符串，再用字符串的contains()方法进行判断</span></span><br></pre></td></tr></table></figure><p>6.4求数组中最大最小值</p><p>假设下标为0的元素是最大值，遍历数组，依次跟max进行比较，如果有元素比这个max还大，则把这个值赋给max。最小值同样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">23</span>,<span class="number">45</span>,<span class="number">234</span>,<span class="number">576</span>,<span class="number">34</span>,<span class="number">87</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]&gt;max)&#123;</span><br><span class="line">        max=arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]&lt;min)&#123;</span><br><span class="line">        min=arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6.5对数组进行排序（冒泡排序）（与Arrays.sort()方法排序效果一样）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">10</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//外层循环控制比较轮数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="comment">//内层循环控制每轮比较次数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">          arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数组-深-浅-拷贝"><a href="#数组-深-浅-拷贝" class="headerlink" title="数组 深/浅 拷贝"></a>数组 深/浅 拷贝</h3><p>将arr拷贝到brr<br>浅拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[]arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>&#125;; </span><br><span class="line">brr=arr; </span><br><span class="line">brr[<span class="number">2</span>]=<span class="number">20</span>;<span class="comment">//new arr[2]也等与20</span></span><br></pre></td></tr></table></figure><p>这种拷贝只是将arr所表示的数组在栈中的地址代码拷贝到了brr中，brr所引用的数组与arr其实就是同一个。因此叫它浅拷贝。</p><p>深拷贝：<br>1.利用for循环结构,逐个将数组arr中的值赋给已经进行了空间开辟的数组brr</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[]arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">int</span>[]brr=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=o;i&lt;arr.length;i++)&#123; </span><br><span class="line">    brr[i]=arr[i]; </span><br><span class="line">     &#125; </span><br><span class="line">brr[<span class="number">2</span>]=<span class="number">30</span>;<span class="comment">//此时arr[2]=5</span></span><br></pre></td></tr></table></figure><p>2.利用Arrays类中的copyOf方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr中所有的元素均被拷贝到brr中，第二个参数便是新数组的长度 </span></span><br><span class="line"><span class="keyword">int</span>[]brr=Arrays.copyOf(arr,arr.length); </span><br><span class="line"><span class="comment">//该方法也可用来增加数组的长度 </span></span><br><span class="line">brr=Arrays.copyOf(arr,<span class="number">2</span>*arr.length);</span><br></pre></td></tr></table></figure><p>3.用System类的arraycopy方法进行拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System.arraycopy(from,fromIndex,to,toIndex,count);</span></span><br><span class="line"><span class="comment">//拷贝从arr的0索引开始到brr的0索引开始，一共拷贝arr.length个元素</span></span><br><span class="line">System.arraycopy(arr,<span class="number">0</span>,brr,<span class="number">0</span>,arr.length);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
            <tag> 数组 </tag>
            
            <tag> 一维数组 </tag>
            
            <tag> 二维数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String/字符串</title>
      <link href="/2017/03/19/String/"/>
      <url>/2017/03/19/String/</url>
      
        <content type="html"><![CDATA[<p>java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。<br>类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻 译为大写或小写的所有字符的字符串的副本。 </p><p>特点：字符串的值在创建后不能被更改（字符串不变）。</p><a id="more"></a><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>public String()：初始化新创建的 String对象，以使其表示空字符序列。</li><li>public String(char[] value)：通过当前参数中的字符数组来构造新的String。 </li><li>public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新String。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有三个构造方法</span></span><br><span class="line"><span class="comment">//无参构造 </span></span><br><span class="line">String str = <span class="keyword">new</span> String（）； </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字符数组构造 </span></span><br><span class="line"><span class="keyword">char</span> chars[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;      </span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字节数组构造 </span></span><br><span class="line"><span class="keyword">byte</span> bytes[] = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;      </span><br><span class="line">String str3 = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure><h3 id="常用方法（操作）"><a href="#常用方法（操作）" class="headerlink" title="常用方法（操作）"></a>常用方法（操作）</h3><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h4><ul><li>public boolean equals (Object anObject)：将此字符串与指定对象进行比较。</li><li>public boolean equalsIgnoreCase (String anotherString)：将此字符串与指定对象进行比较，忽略大小 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo01</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    <span class="comment">// 创建字符串对象     </span></span><br><span class="line">    String s1 = <span class="string">"hello"</span>;     </span><br><span class="line">    String s2 = <span class="string">"hello"</span>;     </span><br><span class="line">    String s3 = <span class="string">"HELLO"</span>;     </span><br><span class="line">    <span class="comment">//boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    <span class="comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br></pre></td></tr></table></figure><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><ul><li>public int length () ：返回此字符串的长度。</li><li>public String concat (String str) ：将指定的字符串连接到该字符串的末尾。</li><li>public char charAt (int index) ：返回指定索引处的 char值。</li><li>public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。</li><li>public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</li><li>public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"helloworld"</span>;</span><br><span class="line">        <span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span></span><br><span class="line">        String s = <span class="string">"helloworld"</span>;</span><br><span class="line">        String s2 = s.concat(<span class="string">"**hello world"</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">// helloworld**hello wolrd</span></span><br><span class="line">        <span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"l"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"owo"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"ak"</span>));</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// String substring(int start):从start开始截取字符串到字符串结尾</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end。</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>, s.length()));</span><br><span class="line">        System.out.println(s.substring(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><ul><li>public char[] toCharArray () ：将此字符串转换为新的字符数组。</li><li>public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li><li>public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"abcde"</span>;</span><br><span class="line">        <span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) &#123;</span><br><span class="line">        System.out.println(chs[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// byte[] getBytes ():把字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bytes.length; x++) &#123;</span><br><span class="line">        System.out.println(bytes[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// 替换字母swu为大写SWU</span></span><br><span class="line">        String str = <span class="string">"swuswu"</span>;</span><br><span class="line">        String replace = str.replace(<span class="string">"swu"</span>, <span class="string">"SWU"</span>);</span><br><span class="line">        System.out.println(replace); <span class="comment">// SWUSWU</span></span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h4><ul><li>public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"aa|bb|cc"</span>;</span><br><span class="line">        String[] strArray = s.split(<span class="string">"|"</span>); <span class="comment">// ["aa","bb","cc"]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; strArray.length; x++) &#123;</span><br><span class="line">        System.out.println(strArray[x]); <span class="comment">// aa bb cc</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>使用String类提供的concat() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string1.concat(string2);</span><br></pre></td></tr></table></figure><p>String类支持的方法（附菜鸟教程的String表格 :<a href="http://www.runoob.com/java/java-string.html）" target="_blank" rel="noopener">http://www.runoob.com/java/java-string.html）</a></p><p><strong><em>具体使用参照以上用法规则</em></strong></p><table><thead><tr><th>SN(序号)</th><th>方法描述</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.runoob.com/java/java-string-charat.html" target="_blank" rel="noopener">char charAt(int index)</a>返回指定索引处的 char 值。</td></tr><tr><td>2</td><td><a href="http://www.runoob.com/java/java-string-compareto.html" target="_blank" rel="noopener">int compareTo(Object o)</a>把这个字符串和另一个对象比较。</td></tr><tr><td>3</td><td><a href="http://www.runoob.com/java/java-string-compareto.html" target="_blank" rel="noopener">int compareTo(String anotherString)</a>按字典顺序比较两个字符串。</td></tr><tr><td>4</td><td><a href="http://www.runoob.com/java/java-string-comparetoignorecase.html" target="_blank" rel="noopener">int compareToIgnoreCase(String str)</a>按字典顺序比较两个字符串，不考虑大小写。</td></tr><tr><td>5</td><td><a href="http://www.runoob.com/java/java-string-concat.html" target="_blank" rel="noopener">String concat(String str)</a>将指定字符串连接到此字符串的结尾。</td></tr><tr><td>6</td><td><a href="http://www.runoob.com/java/java-string-contentequals.html" target="_blank" rel="noopener">boolean contentEquals(StringBuffer sb)</a>当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td></tr><tr><td>7</td><td><a href="http://www.runoob.com/java/java-string-copyvalueof.html" target="_blank" rel="noopener">static String copyValueOf(char[] data)</a>返回指定数组中表示该字符序列的 String。</td></tr><tr><td>8</td><td><a href="http://www.runoob.com/java/java-string-copyvalueof.html" target="_blank" rel="noopener">static String copyValueOf(char[] data, int offset, int count)</a>返回指定数组中表示该字符序列的 String。</td></tr><tr><td>9</td><td><a href="http://www.runoob.com/java/java-string-endswith.html" target="_blank" rel="noopener">boolean endsWith(String suffix)</a>测试此字符串是否以指定的后缀结束。</td></tr><tr><td>10</td><td><a href="http://www.runoob.com/java/java-string-equals.html" target="_blank" rel="noopener">boolean equals(Object anObject)</a>将此字符串与指定的对象比较。</td></tr><tr><td>11</td><td><a href="http://www.runoob.com/java/java-string-equalsignorecase.html" target="_blank" rel="noopener">boolean equalsIgnoreCase(String anotherString)</a>将此 String 与另一个 String 比较，不考虑大小写。</td></tr><tr><td>12</td><td><a href="http://www.runoob.com/java/java-string-getbytes.html" target="_blank" rel="noopener">byte[] getBytes()</a> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td>13</td><td><a href="http://www.runoob.com/java/java-string-getbytes.html" target="_blank" rel="noopener">byte[] getBytes(String charsetName)</a>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td>14</td><td><a href="http://www.runoob.com/java/java-string-getchars.html" target="_blank" rel="noopener">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</a>将字符从此字符串复制到目标字符数组。</td></tr><tr><td>15</td><td><a href="http://www.runoob.com/java/java-string-hashcode.html" target="_blank" rel="noopener">int hashCode()</a>返回此字符串的哈希码。</td></tr><tr><td>16</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(int ch)</a>返回指定字符在此字符串中第一次出现处的索引。</td></tr><tr><td>17</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(int ch, int fromIndex)</a>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td></tr><tr><td>18</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(String str)</a> 返回指定子字符串在此字符串中第一次出现处的索引。</td></tr><tr><td>19</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(String str, int fromIndex)</a>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td></tr><tr><td>20</td><td><a href="http://www.runoob.com/java/java-string-intern.html" target="_blank" rel="noopener">String intern()</a> 返回字符串对象的规范化表示形式。</td></tr><tr><td>21</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(int ch)</a> 返回指定字符在此字符串中最后一次出现处的索引。</td></tr><tr><td>22</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(int ch, int fromIndex)</a>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td></tr><tr><td>23</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(String str)</a>返回指定子字符串在此字符串中最右边出现处的索引。</td></tr><tr><td>24</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td></tr><tr><td>25</td><td><a href="http://www.runoob.com/java/java-string-length.html" target="_blank" rel="noopener">int length()</a>返回此字符串的长度。</td></tr><tr><td>26</td><td><a href="http://www.runoob.com/java/java-string-matches.html" target="_blank" rel="noopener">boolean matches(String regex)</a>告知此字符串是否匹配给定的正则表达式。</td></tr><tr><td>27</td><td><a href="http://www.runoob.com/java/java-string-regionmatches.html" target="_blank" rel="noopener">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a>测试两个字符串区域是否相等。</td></tr><tr><td>28</td><td><a href="http://www.runoob.com/java/java-string-regionmatches.html" target="_blank" rel="noopener">boolean regionMatches(int toffset, String other, int ooffset, int len)</a>测试两个字符串区域是否相等。</td></tr><tr><td>29</td><td><a href="http://www.runoob.com/java/java-string-replace.html" target="_blank" rel="noopener">String replace(char oldChar, char newChar)</a>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td></tr><tr><td>30</td><td><a href="http://www.runoob.com/java/java-string-replaceall.html" target="_blank" rel="noopener">String replaceAll(String regex, String replacement)</a>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td></tr><tr><td>31</td><td><a href="http://www.runoob.com/java/java-string-replacefirst.html" target="_blank" rel="noopener">String replaceFirst(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td></tr><tr><td>32</td><td><a href="http://www.runoob.com/java/java-string-split.html" target="_blank" rel="noopener">String[] split(String regex)</a>根据给定正则表达式的匹配拆分此字符串。</td></tr><tr><td>33</td><td><a href="http://www.runoob.com/java/java-string-split.html" target="_blank" rel="noopener">String[] split(String regex, int limit)</a>根据匹配给定的正则表达式来拆分此字符串。</td></tr><tr><td>34</td><td><a href="http://www.runoob.com/java/java-string-startswith.html" target="_blank" rel="noopener">boolean startsWith(String prefix)</a>测试此字符串是否以指定的前缀开始。</td></tr><tr><td>35</td><td><a href="http://www.runoob.com/java/java-string-startswith.html" target="_blank" rel="noopener">boolean startsWith(String prefix, int toffset)</a>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td></tr><tr><td>36</td><td><a href="http://www.runoob.com/java/java-string-subsequence.html" target="_blank" rel="noopener">CharSequence subSequence(int beginIndex, int endIndex)</a> 返回一个新的字符序列，它是此序列的一个子序列。</td></tr><tr><td>37</td><td><a href="http://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">String substring(int beginIndex)</a>返回一个新的字符串，它是此字符串的一个子字符串。</td></tr><tr><td>38</td><td><a href="http://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">String substring(int beginIndex, int endIndex)</a>返回一个新字符串，它是此字符串的一个子字符串。</td></tr><tr><td>39</td><td><a href="http://www.runoob.com/java/java-string-tochararray.html" target="_blank" rel="noopener">char[] toCharArray()</a>将此字符串转换为一个新的字符数组。</td></tr><tr><td>40</td><td><a href="http://www.runoob.com/java/java-string-tolowercase.html" target="_blank" rel="noopener">String toLowerCase()</a>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td>41</td><td><a href="http://www.runoob.com/java/java-string-tolowercase.html" target="_blank" rel="noopener">String toLowerCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td>42</td><td><a href="http://www.runoob.com/java/java-string-tostring.html" target="_blank" rel="noopener">String toString()</a> 返回此对象本身（它已经是一个字符串！）。</td></tr><tr><td>43</td><td><a href="http://www.runoob.com/java/java-string-touppercase.html" target="_blank" rel="noopener">String toUpperCase()</a>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td>44</td><td><a href="http://www.runoob.com/java/java-string-touppercase.html" target="_blank" rel="noopener">String toUpperCase(Locale locale)</a>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td>45</td><td><a href="http://www.runoob.com/java/java-string-trim.html" target="_blank" rel="noopener">String trim()</a>返回字符串的副本，忽略前导空白和尾部空白。</td></tr><tr><td>46</td><td><a href="http://www.runoob.com/java/java-string-valueof.html" target="_blank" rel="noopener">static String valueOf(primitive data type x)</a>返回给定data type类型x参数的字符串表示形式。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制语句</title>
      <link href="/2017/03/13/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2017/03/13/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果<br>有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现<br>我们要完成的功能。</p><a id="more"></a><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//顺序执行，根据编写的顺序，从上到下运行</span></span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a><strong><em>if</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">if</span>(关系表达式)｛</span><br><span class="line">语句体;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先判断关系表达式看其结果是true还是false</li><li>如果是true就执行语句体</li><li>如果是false就不执行语句体</li></ol><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1t8cccttj30e60bjmy1.jpg" alt="1547126916761"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始"</span>);</span><br><span class="line"><span class="comment">// 定义两个变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//变量使用if判断</span></span><br><span class="line">    <span class="keyword">if</span> (a == b)&#123;</span><br><span class="line">    System.out.println(<span class="string">"a等于b"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == c)&#123;</span><br><span class="line">    System.out.println(<span class="string">"a等于c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h5 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a><strong><em>if…else</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先判断关系表达式看其结果是true还是false</li><li>如果是true就执行语句体1</li><li>如果是false就执行语句体2</li></ol><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1tbqggjsj30ex0bs75c.jpg" alt="1547127135299"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断给定的数据是奇数还是偶数</span></span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"a是偶数"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a是奇数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="if-else-if…else"><a href="#if-else-if…else" class="headerlink" title="if..else if…else"></a><strong><em>if..else if…else</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>) &#123;</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先判断关系表达式1看其结果是true还是false</li><li>如果是true就执行语句体1</li><li>如果是false就继续判断关系表达式2看其结果是true还是false</li><li>如果是true就执行语句体2</li><li>如果是false就继续判断关系表达式…看其结果是true还是false</li><li>…</li><li>如果没有任何关系表达式为true，就执行语句体n+1。</li></ol><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1tfe3m3fj30o80kvacs.jpg" alt="1547127344405"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x和y的关系满足如下：</span></span><br><span class="line">    <span class="comment">// x&gt;=3 y = 2x + 1;</span></span><br><span class="line">    <span class="comment">//‐1&lt;=x&lt;3 y = 2x;</span></span><br><span class="line">    <span class="comment">// x&lt;=‐1 y = 2x – 1;</span></span><br><span class="line">    <span class="comment">// 根据给定的x的值，计算出y的值并输出。</span></span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= ‐<span class="number">1</span> &amp;&amp; x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y = <span class="number">2</span> * x ‐ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"y的值是："</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a><strong><em>switch</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先计算出表达式的值</li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ol><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1tja6zvgj30n30bwabv.jpg" alt="1547127571620"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义变量，判断是星期几</span></span><br><span class="line">    <span class="keyword">int</span> weekday = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//switch语句实现选择</span></span><br><span class="line">    <span class="keyword">switch</span>(weekday) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"星期一"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"星期二"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"你输入的数字有误"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。</span></span><br></pre></td></tr></table></figure><h5 id="case的穿透性"><a href="#case的穿透性" class="headerlink" title="case的穿透性"></a><strong><em>case的穿透性</em></strong></h5><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运<br>行，直到遇到break，或者整体switch结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"执行case0"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            System.out.println(<span class="string">"执行case5"</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        System.out.println(<span class="string">"执行case10"</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"执行default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会break，直接</span></span><br><span class="line"><span class="comment">//运行完整体switch。</span></span><br><span class="line"><span class="comment">//由于case存在穿透性，因此初学者在编写switch语句时，必须要写上break。</span></span><br></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for"><a href="#for" class="headerlink" title="for"></a><strong><em>for</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">for</span>(初始化表达式<span class="number">1</span>; 布尔表达式<span class="number">2</span>; 步进表达式<span class="number">3</span>)&#123;</span><br><span class="line">循环体<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程<br>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>①负责完成循环变量初始化<br>②负责判断是否满足循环条件，不满足则跳出循环<br>③具体执行的语句<br>④循环后，循环条件所涉及变量的变化情况</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1tr686vwj30d40czdh7.jpg" alt="1547128025686"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制台输出4次HelloWorld，不使用循环</span></span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    <span class="comment">//用循环改进，循环3次</span></span><br><span class="line">    <span class="comment">//定义变量从0开始，循环条件为&lt;3</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg 2 使用循环，计算1-100之间的偶数和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义一个初始化变量,记录累加求和,初始值为0</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.利用for循环获取1‐100之间的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//3.判断获取的数组是奇数还是偶数</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//4.如果是偶数就累加求和</span></span><br><span class="line">        sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.循环结束之后,打印累加结果</span></span><br><span class="line">    System.out.println(<span class="string">"sum:"</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="while"><a href="#while" class="headerlink" title="while"></a><strong><em>while</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程<br>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>①负责完成循环变量初始化。<br>②负责判断是否满足循环条件，不满足则跳出循环。<br>③具体执行的语句。<br>④循环后，循环变量的变化情况。</p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1tvj7v9uj30an0bvgmn.jpg" alt="1547128275709"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//while循环实现打印10次HelloWorld</span></span><br><span class="line">    <span class="comment">//定义初始化变量</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环条件&lt;=10</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        <span class="comment">//步进</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg 2 while循环计算1-100之间的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用while循环实现</span></span><br><span class="line">    <span class="comment">//定义一个变量,记录累加求和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义初始化表达式</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//使用while循环让初始化表达式的值变化</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="comment">//累加求和</span></span><br><span class="line">    sum += i ;</span><br><span class="line">        <span class="comment">//步进表达式改变变量的值</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印求和的变量</span></span><br><span class="line">    System.out.println(<span class="string">"1‐100的和是："</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a><strong><em>do…while</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure><p>执行流程<br>执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。<br>①负责完成循环变量初始化。<br>②负责判断是否满足循环条件，不满足则跳出循环。<br>③具体执行的语句<br>④循环后，循环变量的变化情况</p><p><img src="http://wx4.sinaimg.cn/mw690/0077hIeDly1fz1tzr10a0j30dr0fbwgi.jpg" alt="1547128484462"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(x&lt;=<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do…while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。这样的<br>循环具有一定的风险性，因此初学者不建议使用do…while循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"无条件执行一次"</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环语句的区别</p><p>for 和 while 的小区别：<br>1.控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继<br>   续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消<br>   失，能够提高内存的使用效率。<br>2.在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</p><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。例如：while(true){}。欲想结束死循环就要用到跳出语句。</p><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p>所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总<br>共的循环次数=外循环次数*内循环次数<br>嵌套循环格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①; 循环条件②; 步进表达式⑦) &#123;</span><br><span class="line">    <span class="keyword">for</span>(初始化表达式③; 循环条件④; 步进表达式⑥) &#123;</span><br><span class="line">    执行语句⑤;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套循环执行流程：<br>执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥<br>外循环一次，内循环多次。<br>比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。</p><h3 id="跳出语句"><a href="#跳出语句" class="headerlink" title="跳出语句"></a>跳出语句</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>使用场景：终止switch或者循环</p><ul><li>在选择结构switch语句中</li><li>在循环语句中</li><li>离开使用场景的存在是没有意义的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//需求:打印完两次HelloWorld之后结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>使用场景：结束本次循环，继续下一次的循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//需求:不打印第三次HelloWorld</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 流程控制语句 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门简介以及环境搭建(JDK安装&amp;配置环境变量)</title>
      <link href="/2017/03/13/Java%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(JDK%E5%AE%89%E8%A3%85&amp;%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)/"/>
      <url>/2017/03/13/Java%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(JDK%E5%AE%89%E8%A3%85&amp;%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)/</url>
      
        <content type="html"><![CDATA[<p>Java语言概述：Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><a id="more"></a><h3 id="Java语言发展历史"><a href="#Java语言发展历史" class="headerlink" title="Java语言发展历史"></a>Java语言发展历史</h3><ol><li>1995年Sun公司发布Java1.0版本</li><li>1997年发布Java 1.1版本</li><li>1998年发布Java 1.2版本</li><li>2000年发布Java 1.3版本</li><li>2002年发布Java 1.4版本</li><li>2004年发布Java 1.5版本</li><li>2006年发布Java 1.6版本</li><li>2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 1.7版本</li><li>2014年发布Java 1.8版本</li><li>2017年发布Java 9.0版本</li></ol><p>Java语言主要应用在互联网程序的开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服<br>务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。</p><h3 id="Java语言开发环境搭建"><a href="#Java语言开发环境搭建" class="headerlink" title="Java语言开发环境搭建"></a>Java语言开发环境搭建</h3><h4 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h4><p>学习开发环境之前，首先来了解一下JVM虚拟机。</p><p>Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在JVM 之上。<br>跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系<br>统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM<br>运行在操作系统上。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1s2z0el7j30i5070q5d.jpg" alt="JVM"></p><p>JDK与JRE：</p><p>JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含JVM 和运行时所需要的核心类库 。<br>JDK (Java Development Kit)：是Java程序开发工具包，包含JRE 和开发人员使用的工具。<br>我们想要运行一个已有的Java程序，那么只需安装JRE 即可。<br>我们想要开发一个全新的Java程序，那么必须安装JDK 。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1s6a99rxj30n10f3n7o.jpg" alt="null"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//三者关系</span><br><span class="line">JDK &gt; JRE &gt; JVM</span><br></pre></td></tr></table></figure><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>安装的文件不要有中文和空格！（本文以jdk9为例）</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1salpnqaj30e40awwgq.jpg" alt="1547124983933"></p><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1sg2ha0ij30e70amtc8.jpg" alt="1547125280563"></p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1sgrivh2j30e40awjto.jpg" alt="1547125346294"></p><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1sifa9ldj30ea0asmzm.jpg" alt="1547125427398"></p><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1sjyjhi8j30ed0astay.jpg" alt="1547125479599"></p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>安装完JDK之后还需要配置系统的环境变量，因为程序开发中，需要用到JDK提高的工具包。</p><p>环境变量的配置直接从百度爬过来的。附上连接，我就不一一截图了。</p><p>[<a href="https://jingyan.baidu.com/article/d45ad148ba5ab169552b80d3.html]" target="_blank" rel="noopener">https://jingyan.baidu.com/article/d45ad148ba5ab169552b80d3.html]</a>:</p>]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK安装 </tag>
            
            <tag> 环境变量配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2017/03/09/hello-hexo/"/>
      <url>/2017/03/09/hello-hexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
