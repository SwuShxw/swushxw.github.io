<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FreeMarker</title>
      <link href="/2019/01/28/FreeMarker/"/>
      <url>/2019/01/28/FreeMarker/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>FreeMarker是一款用Java编写的模板引擎： 即一种基于模板和要改变的数据，并用来生成输出文本(HTML网页、电子邮件、配置文件、源代码等)的通用工具。是一个Java类库。</p><p>​ FreeMarker 与 Web 容器无关，即在 Web 运行时，它并不知道 Servlet 或 HTTP。它不仅 可以用作表现层的实现技术，而且还可以用于生成 XML，JSP 或 Java 等。</p><a id="more"></a><h3 id="模板引擎执行流程"><a href="#模板引擎执行流程" class="headerlink" title="模板引擎执行流程"></a><strong>模板引擎执行流程</strong></h3><p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=72bf38a83987e950561afb3e71513826/738b4710b912c8fc0771c1a6ff039245d78821de.jpg" alt=""></p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=086de59297ef76c6c4dff379fc7f969f/faedab64034f78f01a86ad407e310a55b2191cf7.jpg" alt=""></p><p><strong>FreeMarker语法</strong></p><p>FreeMarker的模板文件并不比HTML页面复杂多少,FreeMarker模板文件主要由如下4个部分组成:</p><ol><li>文本:直接输出的部分</li><li>注释:&lt;#– … –&gt;格式部分,不会输出</li><li>插值:即${…}或#{…}格式的部分,将使用数据模型中的部分替代输出</li><li>FTL指令:FreeMarker指定,和HTML标记类似,名字前加#予以区分,不会输出</li></ol><p>下面是一个FreeMarker模板的例子,包含了以上所说的4个部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome!<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#--</span> 注释部分 <span class="attr">--</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#--</span> 下面使用插值 <span class="attr">--</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome $&#123;user&#125; !<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>We have these animals:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">u1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#--</span> 使用<span class="attr">FTL</span>指令 <span class="attr">--</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#list</span> <span class="attr">animals</span> <span class="attr">as</span> <span class="attr">being</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>$&#123;being.name&#125; for $&#123;being.price&#125; Euros<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">#list</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">u1</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="FTL指令规则"><a href="#FTL指令规则" class="headerlink" title="FTL指令规则"></a><strong>FTL指令规则</strong></h3><p>在FreeMarker中,使用FTL标签来使用指令,FreeMarker有3种FTL标签,这和HTML标签是完全类似的.</p><ol><li>开始标签:&lt;#directivename parameter&gt;</li><li>结束标签:&lt;/#directivename&gt;</li><li>空标签:&lt;#directivename parameter/&gt;</li></ol><p>实际上,使用标签时前面的符号#也可能变成@,如果该指令是一个用户指令而不是系统内建指令时,应将#符号改成@符号.</p><p>使用FTL标签时,应该有正确的嵌套,而不是交叉使用,这和XML标签的用法完全一样.如果全用不存在的指令,FreeMarker不会使用模板输出,而是产生一个错误消息.FreeMarker会忽略FTL标签中的空白字符.值得注意的是&lt; , /&gt; 和指令之间不允许有空白字符.</p><h3 id="插值规则"><a href="#插值规则" class="headerlink" title="插值规则"></a><strong>插值规则</strong></h3><p>FreeMarker的插值有如下两种类型:1,通用插值${expr};2,数字格式化插值:#{expr}或#{expr;format}</p><p><strong>通用插值</strong></p><p>对于通用插值,又可以分为以下4种情况:</p><p>1,插值结果为字符串值:直接输出表达式结果</p><p>2,插值结果为数字值:根据默认格式(由#setting指令设置)将表达式结果转换成文本输出.可以使用内建的字符串函数格式化单个插值,如下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;#settion number_format=&quot;currency&quot;/&gt;</span><br><span class="line">&lt;#assign answer=42/&gt;</span><br><span class="line">$&#123;answer&#125;</span><br><span class="line">$&#123;answer?string&#125; &lt;#-- the same as $&#123;answer&#125; --&gt;</span><br><span class="line">$&#123;answer?string.number&#125;</span><br><span class="line">$&#123;answer?string.currency&#125;</span><br><span class="line">$&#123;answer?string.percent&#125;</span><br><span class="line">$&#123;answer&#125;</span><br><span class="line">输出结果是:</span><br><span class="line">$42.00</span><br><span class="line">$42.00</span><br><span class="line">42</span><br><span class="line">$42.00</span><br><span class="line">4,200%</span><br></pre></td></tr></table></figure><p>3,插值结果为日期值:根据默认格式(由#setting指令设置)将表达式结果转换成文本输出.可以使用内建的字符串函数格式化单个插值,如下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;lastUpdated?string(&quot;yyyy-MM-dd HH:mm:ss zzzz&quot;)&#125;</span><br><span class="line">$&#123;lastUpdated?string(&quot;EEE, MMM d, &apos;&apos;yy&quot;)&#125;</span><br><span class="line">$&#123;lastUpdated?string(&quot;EEEE, MMMM dd, yyyy, hh:mm:ss a &apos;(&apos;zzz&apos;)&apos;&quot;)&#125;</span><br><span class="line">输出结果是:</span><br><span class="line">2008-04-08 08:08:08 Pacific Daylight Time</span><br><span class="line">Tue, Apr 8, &apos;03</span><br><span class="line">Tuesday, April 08, 2003, 08:08:08 PM (PDT)</span><br></pre></td></tr></table></figure><p>4,插值结果为布尔值:根据默认格式(由#setting指令设置)将表达式结果转换成文本输出.可以使用内建的字符串函数格式化单个插值,如下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign foo=true/&gt;</span><br><span class="line">$&#123;foo?string(&quot;yes&quot;, &quot;no&quot;)&#125;</span><br><span class="line">输出结果是:</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><p><strong>数字格式化插值</strong></p><p>数字格式化插值可采用#{expr;format}形式来格式化数字,其中format可以是:</p><p>mX:小数部分最小X位</p><p>MX:小数部分最大X位</p><p>如下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign x=2.582/&gt;</span><br><span class="line">&lt;#assign y=4/&gt;</span><br><span class="line">#&#123;x; M2&#125; &lt;#-- 输出2.58 --&gt;</span><br><span class="line">#&#123;y; M2&#125; &lt;#-- 输出4 --&gt;</span><br><span class="line">#&#123;x; m2&#125; &lt;#-- 输出2.6 --&gt;</span><br><span class="line">#&#123;y; m2&#125; &lt;#-- 输出4.0 --&gt;</span><br><span class="line">#&#123;x; m1M2&#125; &lt;#-- 输出2.58 --&gt;</span><br><span class="line">#&#123;x; m1M2&#125; &lt;#-- 输出4.0 --&gt;</span><br></pre></td></tr></table></figure><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a><strong>表达式</strong></h3><p>表达式是FreeMarker模板的核心功能,表达式放置在插值语法${}之中时,表明需要输出表达式的值;表达式语法也可与FreeMarker标签结合,用于控制输出.实际上FreeMarker的表达式功能非常强大,它不仅支持直接指定值,输出变量值,也支持字符串格式化输出和集合访问等功能.</p><p><strong>直接指定值</strong></p><p>使用直接指定值语法让FreeMarker直接输出插值中的值,而不是输出变量值.直接指定值可以是字符串,数值,布尔值,集合和MAP对象.</p><p>1,<em>字符串</em></p><p>直接指定字符串值使用单引号或双引号限定,如果字符串值中包含特殊字符需要转义,看下面的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&quot;我的文件保存在C:\\盘&quot;&#125;</span><br><span class="line">$&#123;&apos;我名字是\&quot;annlee\&quot;&apos;&#125;</span><br><span class="line">输出结果是: </span><br><span class="line">我的文件保存在C:\盘</span><br><span class="line">我名字是&quot;annlee&quot;</span><br></pre></td></tr></table></figure><p>FreeMarker支持如下转义字符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\&quot;;双引号(u0022)</span><br><span class="line">\&apos;;单引号(u0027)</span><br><span class="line">\\;反斜杠(u005C)</span><br><span class="line">\n;换行(u000A)</span><br><span class="line">\r;回车(u000D)</span><br><span class="line">\t;Tab(u0009)</span><br><span class="line">\b;退格键(u0008)</span><br><span class="line">\f;Form feed(u000C)</span><br><span class="line">\l;&lt;</span><br><span class="line">\g;&gt;</span><br><span class="line">\a;&amp;</span><br><span class="line">\&#123;;&#123;</span><br><span class="line">\xCode;直接通过4位的16进制数来指定Unicode码,输出该unicode码对应的字符.</span><br></pre></td></tr></table></figure><p>如果某段文本中包含大量的特殊符号,FreeMarker提供了另一种特殊格式:可以在指定字符串内容的引号前增加r标记,在r标记后的文件将会直接输出.看如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$&#123;r&quot;$&#123;foo&#125;&quot;&#125;</span><br><span class="line">$&#123;r&quot;C:\foo\bar&quot;&#125;</span><br><span class="line">输出结果是:</span><br><span class="line">$&#123;foo&#125;</span><br><span class="line">C:\foo\bar</span><br></pre></td></tr></table></figure><p><em>数值</em></p><p>表达式中的数值直接输出,不需要引号.小数点使用”.”分隔,不能使用分组”,”符号.FreeMarker目前还不支持科学计数法,所以”1E3”是错误的.在FreeMarker表达式中使用数值需要注意以下几点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数值不能省略小数点前面的0,所以&quot;.5&quot;是错误的写法</span><br><span class="line">数值8 , +8 , 8.00都是相同的</span><br></pre></td></tr></table></figure><p><em>布尔值</em></p><p>直接使用true和false,不使用引号.</p><p><em>集合</em></p><p>集合以方括号包括,各集合元素之间以英文逗号”,”分隔,看如下的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;</span><br><span class="line">$&#123;x&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line">输出结果是:</span><br><span class="line">星期一</span><br><span class="line">星期二</span><br><span class="line">星期三</span><br><span class="line">星期四</span><br><span class="line">星期五</span><br><span class="line">星期六</span><br><span class="line">星期天</span><br></pre></td></tr></table></figure><p>除此之外,集合元素也可以是表达式,例子如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2 + 2, [1, 2, 3, 4], &quot;whatnot&quot;]</span><br></pre></td></tr></table></figure><p>还可以使用数字范围定义数字集合,如2..5等同于[2, 3, 4, 5],但是更有效率.注意,使用数字范围来定义集合时无需使用方括号,数字范围也支持反递增的数字范围,如5..2</p><p><em>Map对象</em></p><p>Map对象使用花括号包括,Map中的key-value对之间以英文冒号”:”分隔,多组key-value对之间以英文逗号”,”分隔.下面是一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;语文&quot;:78, &quot;数学&quot;:80&#125;</span><br></pre></td></tr></table></figure><p>Map对象的key和value都是表达式,但是key必须是字符串</p><p><strong>输出变量值</strong></p><p>FreeMarker的表达式输出变量时,这些变量可以是顶层变量,也可以是Map对象中的变量,还可以是集合中的变量,并可以使用点(.)语法来访问Java对象的属性.下面分别讨论这些情况</p><p><em>顶层变量</em></p><p>所谓顶层变量就是直接放在数据模型中的值,例如有如下数据模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map root = new HashMap();   //创建数据模型</span><br><span class="line">root.put(&quot;name&quot;,&quot;annlee&quot;);   //name是一个顶层变量</span><br></pre></td></tr></table></figure><p>对于顶层变量,直接使用${variableName}来输出变量值,变量名只能是字母,数字,下划线,$,@和#的组合,且不能以数字开头号.为了输出上面的name的值,可以使用如下语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;name&#125;</span><br></pre></td></tr></table></figure><p><em>输出集合元素</em></p><p>如果需要输出集合元素,则可以根据集合元素的索引来输出集合元素,集合元素的索引以方括号指定.假设有索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;].该索引名为week,如果需要输出星期三,则可以使用如下语法:</span><br><span class="line">$&#123;week[2]&#125;   //输出第三个集合元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此外,FreeMarker还支持返回集合的子集合,如果需要返回集合的子集合,则可以使用如下语法:</span><br><span class="line">week[3..5]   //返回week集合的子集合,子集合中的元素是week集合中的第4-6个元素</span><br></pre></td></tr></table></figure><p><em>输出Map元素</em></p><p>这里的Map对象可以是直接HashMap的实例,甚至包括JavaBean实例,对于JavaBean实例而言,我们一样可以把其当成属性为key,属性值为value的Map实例.为了输出Map元素的值,可以使用点语法或方括号语法.假如有下面的数据模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map root = new HashMap();</span><br><span class="line">Book book = new Book();</span><br><span class="line">Author author = new Author();</span><br><span class="line">author.setName(&quot;annlee&quot;);</span><br><span class="line">author.setAddress(&quot;gz&quot;);</span><br><span class="line">book.setName(&quot;struts2&quot;);</span><br><span class="line">book.setAuthor(author);</span><br><span class="line">root.put(&quot;info&quot;,&quot;struts&quot;);</span><br><span class="line">root.put(&quot;book&quot;, book);</span><br></pre></td></tr></table></figure><p>为了访问数据模型中名为struts2的书的作者的名字,可以使用如下语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">book.author.name    //全部使用点语法</span><br><span class="line">book[&quot;author&quot;].name</span><br><span class="line">book.author[&quot;name&quot;]    //混合使用点语法和方括号语法</span><br><span class="line">book[&quot;author&quot;][&quot;name&quot;]   //全部使用方括号语法</span><br></pre></td></tr></table></figure><p>使用点语法时,变量名字有顶层变量一样的限制,但方括号语法没有该限制,因为名字可以是任意表达式的结果.</p><p><em>字符串操作</em></p><p>FreeMarker的表达式对字符串操作非常灵活,可以将字符串常量和变量连接起来,也可以返回字符串的子串等.</p><p>字符串连接有两种语法:</p><p>1,使用${..}或#{..}在字符串常量部分插入表达式的值,从而完成字符串连接.</p><p>2,直接使用连接运算符+来连接字符串</p><p>例如有如下数据模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map root = new HashMap(); root.put(&quot;user&quot;,&quot;annlee&quot;);</span><br></pre></td></tr></table></figure><p>下面将user变量和常量连接起来:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&quot;hello, $&#123;user&#125;!&quot;&#125;   //使用第一种语法来连接</span><br><span class="line">$&#123;&quot;hello, &quot; + user + &quot;!&quot;&#125; //使用+号来连接</span><br></pre></td></tr></table></figure><p>上面的输出字符串都是hello,annlee!,可以看出这两种语法的效果完全一样.</p><p>值得注意的是,${..}只能用于文本部分,不能用于表达式,下面的代码是错误的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if $&#123;isBig&#125;&gt;Wow!&lt;/#if&gt;</span><br><span class="line">&lt;#if &quot;$&#123;isBig&#125;&quot;&gt;Wow!&lt;/#if&gt;</span><br><span class="line">应该写成:&lt;#if isBig&gt;Wow!&lt;/#if&gt;</span><br></pre></td></tr></table></figure><p>截取子串可以根据字符串的索引来进行,截取子串时如果只指定了一个索引值,则用于取得字符串中指定索引所对应的字符;如果指定两个索引值,则返回两个索引中间的字符串子串.假如有如下数据模型:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map root = new HashMap(); root.put(&quot;book&quot;,&quot;struts2,freemarker&quot;);</span><br><span class="line">可以通过如下语法来截取子串:</span><br><span class="line">$&#123;book[0]&#125;$&#123;book[4]&#125;   //结果是su</span><br><span class="line">$&#123;book[1..4]&#125;     //结果是tru</span><br></pre></td></tr></table></figure><p><em>集合连接运算符</em></p><p>这里所说的集合运算符是将两个集合连接成一个新的集合,连接集合的运算符是+,看如下的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list [&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;] + [&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;] as x&gt;</span><br><span class="line">$&#123;x&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line">输出结果是:星期一 星期二 星期三 星期四 星期五 星期六 星期天</span><br></pre></td></tr></table></figure><p><em>Map连接运算符</em></p><p>Map对象的连接运算符也是将两个Map对象连接成一个新的Map对象,Map对象的连接运算符是+,如果两个Map对象具有相同的key,则右边的值替代左边的值.看如下的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign scores = &#123;&quot;语文&quot;:86,&quot;数学&quot;:78&#125; + &#123;&quot;数学&quot;:87,&quot;Java&quot;:93&#125;&gt;</span><br><span class="line">语文成绩是$&#123;scores.语文&#125;</span><br><span class="line">数学成绩是$&#123;scores.数学&#125;</span><br><span class="line">Java成绩是$&#123;scores.Java&#125;</span><br><span class="line">输出结果是:</span><br><span class="line">语文成绩是86</span><br><span class="line">数学成绩是87</span><br><span class="line">Java成绩是93</span><br></pre></td></tr></table></figure><p><em>算术运算符</em></p><p>FreeMarker表达式中完全支持算术运算,FreeMarker支持的算术运算符包括:+, - , * , / , % 看如下的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign x=5&gt;</span><br><span class="line">$&#123; x * x - 100 &#125;</span><br><span class="line">$&#123; x /2 &#125;</span><br><span class="line">$&#123; 12 %10 &#125;</span><br><span class="line">输出结果是:</span><br><span class="line">-75   2.5   2</span><br></pre></td></tr></table></figure><p>在表达式中使用算术运算符时要注意以下几点:</p><p>1,运算符两边的运算数字必须是数字</p><p>2,使用+运算符时,如果一边是数字,一边是字符串,就会自动将数字转换为字符串再连接,如:${3 + “5”},结果是:35</p><p>使用内建的int函数可对数值取整,如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign x=5&gt;</span><br><span class="line">$&#123; (x/2)?int &#125;</span><br><span class="line">$&#123; 1.1?int &#125;</span><br><span class="line">$&#123; 1.999?int &#125;</span><br><span class="line">$&#123; -1.1?int &#125;</span><br><span class="line">$&#123; -1.999?int &#125;</span><br><span class="line">结果是:2 1 1 -1 -1</span><br></pre></td></tr></table></figure><p><em>比较运算符比较运算符</em></p><p>表达式中支持的比较运算符有如下几个:</p><ol><li>=或者==:判断两个值是否相等.</li><li>!=:判断两个值是否不等.</li><li>‘&gt;’或者gt:判断左边值是否大于右边值</li><li>‘&gt;=’或者gte:判断左边值是否大于等于右边值</li><li>&lt;或者lt:判断左边值是否小于右边值</li><li>&lt;=或者lte:判断左边值是否小于等于右边值</li></ol><p>注意:=和!=可以用于字符串,数值和日期来比较是否相等,但=和!=两边必须是相同类型的值,否则会产生错误,而且FreeMarker是精确比较,”x”,”x “,”X”是不等的.其它的运行符可以作用于数字和日期,但不能作用于字符串,大部分的时候,使用gt等字母运算符代替&gt;会有更好的效果,因为FreeMarker会把&gt;解释成FTL标签的结束字符,当然,也可以使用括号来避免这种情况,如:&lt;#if (x&gt;y)&gt;</p><p><em>逻辑运算符</em></p><p>逻辑运算符有如下几个:</p><p>逻辑与:&amp;&amp;</p><p>逻辑或:||</p><p>逻辑非:!</p><p>逻辑运算符只能作用于布尔值,否则将产生错误</p><p><em>内建函数</em></p><p>FreeMarker还提供了一些内建函数来转换输出,可以在任何变量后紧跟” ? “,” ? “后紧跟内建函数,就可以通过内建函数来轮换输出变量.下面是常用的内建的字符串函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">html:对字符串进行HTML编码</span><br><span class="line">cap_first:使字符串第一个字母大写</span><br><span class="line">lower_case:将字符串转换成小写</span><br><span class="line">upper_case:将字符串转换成大写</span><br><span class="line">trim:去掉字符串前后的空白字符</span><br></pre></td></tr></table></figure><p>下面是集合的常用内建函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">size:获取序列中元素的个数</span><br><span class="line">下面是数字值的常用内建函数</span><br><span class="line">int:取得数字的整数部分,结果带符号</span><br><span class="line">例如:</span><br><span class="line">&lt;#assign test=&quot;Tom &amp; Jerry&quot;&gt;</span><br><span class="line">$&#123;test?html&#125;</span><br><span class="line">$&#123;test?upper_case?html&#125;</span><br><span class="line">结果是:Tom &amp;amp; Jerry   TOM &amp;amp; JERRY</span><br></pre></td></tr></table></figure><p><em>空值处理运算符</em></p><p>FreeMarker对空值的处理非常严格,FreeMarker的变量必须有值,没有被赋值的变量就会抛出异常,因为FreeMarker未赋值的变量强制出错可以杜绝很多潜在的错误,如缺失潜在的变量命名,或者其他变量错误.这里所说的空值,实际上也包括那些并不存在的变量,对于一个Java的null值而言,我们认为这个变量是存在的,只是它的值为null,但对于FreeMarker模板而言,它无法理解null值,null值和不存在的变量完全相同.</p><p>为了处理缺失变量,FreeMarker提供了两个运算符:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!:指定缺失变量的默认值</span><br><span class="line">??:判断某个变量是否存在</span><br></pre></td></tr></table></figure><p>其中,!运算符的用法有如下两种:</p><p>variable!或variable!defaultValue,第一种用法不给缺失的变量指定默认值,表明默认值是空字符串,长度为0的集合,或者长度为0的Map对象.</p><p>使用!指定默认值时,并不要求默认值的类型和变量类型相同.使用??运算符非常简单,它总是返回一个布尔值,用法为:variable??,如果该变量存在,返回true,否则返回false</p><p><em>运算符的优先级</em></p><p>FreeMarker中的运算符优先级如下(由高到低排列):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1,一元运算符:!</span><br><span class="line">2,内建函数:?</span><br><span class="line">3,乘除法:*, / , %</span><br><span class="line">4,加减法:- , +</span><br><span class="line">5,比较:&gt; , &lt; , &gt;= , &lt;= (lt , lte , gt , gte)</span><br><span class="line">6,相等:== , = , !=</span><br><span class="line">7,逻辑与:&amp;&amp;</span><br><span class="line">8,逻辑或:||</span><br><span class="line">9,数字范围:..</span><br></pre></td></tr></table></figure><p>实际上,我们在开发过程中应该使用括号来严格区分,这样的可读性好,出错少</p><h3 id="FreeMarker的常用指令"><a href="#FreeMarker的常用指令" class="headerlink" title="FreeMarker的常用指令"></a><strong>FreeMarker的常用指令</strong></h3><p>FreeMarker的FTL指令也是模板的重要组成部分,这些指令可实现对数据模型所包含数据的抚今迭代,分支控制.除此之外,还有一些重要的功能,也是通过FTL指令来实现的.</p><p><em>if指令</em></p><p>这是一个典型的分支控制指令,该指令的作用完全类似于Java语言中的if,if指令的语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if condition&gt;...</span><br><span class="line">&lt;#elseif condition&gt;...</span><br><span class="line">&lt;#elseif condition&gt;...</span><br><span class="line">&lt;#else&gt; ...</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line">例子如下:</span><br><span class="line">&lt;#assign age=23&gt;</span><br><span class="line">&lt;#if (age&gt;60)&gt;老年人</span><br><span class="line">&lt;#elseif (age&gt;40)&gt;中年人</span><br><span class="line">&lt;#elseif (age&gt;20)&gt;青年人</span><br><span class="line">&lt;#else&gt; 少年人</span><br><span class="line">&lt;/#if&gt;</span><br><span class="line">输出结果是:青年人</span><br></pre></td></tr></table></figure><p>上面的代码中的逻辑表达式用括号括起来主要是因为里面有&gt;符号,由于FreeMarker会将&gt;符号当成标签的结束字符,可能导致程序出错,为了避免这种情况,我们应该在凡是出现这些符号的地方都使用括号.</p><p><em>switch , case , default , break指令</em></p><p>这些指令显然是分支指令,作用类似于Java的switch语句,switch指令的语法结构如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#switch value&gt;</span><br><span class="line">&lt;#case refValue&gt;...&lt;#break&gt;</span><br><span class="line">&lt;#case refValue&gt;...&lt;#break&gt;</span><br><span class="line">&lt;#default&gt;...</span><br><span class="line">&lt;/#switch&gt;</span><br></pre></td></tr></table></figure><p><em>list, break指令</em></p><p>list指令是一个迭代输出指令,用于迭代输出数据模型中的集合,list指令的语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#list sequence as item&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p>上面的语法格式中,sequence就是一个集合对象,也可以是一个表达式,但该表达式将返回一个集合对象,而item是一个任意的名字,就是被迭代输出的集合元素.此外,迭代集合对象时,还包含两个特殊的循环变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">item_index:当前变量的索引值</span><br><span class="line">item_has_next:是否存在下一个对象</span><br><span class="line">也可以使用&lt;#break&gt;指令跳出迭代</span><br><span class="line">例子如下:</span><br><span class="line">&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as x&gt;</span><br><span class="line">$&#123;x_index + 1&#125;.$&#123;x&#125;&lt;#if x_has_next&gt;,&lt;/if&gt;</span><br><span class="line">&lt;#if x=&quot;星期四&quot;&gt;&lt;#break&gt;&lt;/#if&gt;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p><em>include指令</em></p><p>include指令的作用类似于JSP的包含指令,用于包含指定页.include指令的语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#include filename [options]&gt;</span><br><span class="line">在上面的语法格式中,两个参数的解释如下:</span><br><span class="line">filename:该参数指定被包含的模板文件</span><br><span class="line">options:该参数可以省略,指定包含时的选项,包含encoding和parse两个选项,其中encoding指定包含页面时所用的解码集,而parse指定被包含文件是否作为FTL文件来解析,如果省略了parse选项值,则该选项默认是true.</span><br></pre></td></tr></table></figure><p><em>import指令</em></p><p>该指令用于导入FreeMarker模板中的所有变量,并将该变量放置在指定的Map对象中,import指令的语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#import &quot;/lib/common.ftl&quot; as com&gt;</span><br><span class="line">上面的代码将导入/lib/common.ftl模板文件中的所有变量,交将这些变量放置在一个名为com的Map对象中.</span><br></pre></td></tr></table></figure><p><em>noparse指令</em></p><p>noparse指令指定FreeMarker不处理该指定里包含的内容,该指令的语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#noparse&gt;...&lt;/#noparse&gt;</span><br><span class="line">看如下的例子:</span><br><span class="line">&lt;#noparse&gt;</span><br><span class="line">&lt;#list books as book&gt;</span><br><span class="line">   &lt;tr&gt;&lt;td&gt;$&#123;book.name&#125;&lt;td&gt;作者:$&#123;book.author&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line">&lt;/#noparse&gt;</span><br><span class="line">输出如下:</span><br><span class="line">&lt;#list books as book&gt;</span><br><span class="line">   &lt;tr&gt;&lt;td&gt;$&#123;book.name&#125;&lt;td&gt;作者:$&#123;book.author&#125;</span><br><span class="line">&lt;/#list&gt;</span><br></pre></td></tr></table></figure><p><em>escape , noescape指令</em></p><p>escape指令导致body区的插值都会被自动加上escape表达式,但不会影响字符串内的插值,只会影响到body内出现的插值,使用escape指令的语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;#escape identifier as expression&gt;...</span><br><span class="line">&lt;#noescape&gt;...&lt;/#noescape&gt;</span><br><span class="line">&lt;/#escape&gt;</span><br><span class="line">看如下的代码:</span><br><span class="line">&lt;#escape x as x?html&gt;</span><br><span class="line">First name:$&#123;firstName&#125;</span><br><span class="line">Last name:$&#123;lastName&#125;</span><br><span class="line">Maiden name:$&#123;maidenName&#125;</span><br><span class="line">&lt;/#escape&gt;</span><br><span class="line">上面的代码等同于:</span><br><span class="line">First name:$&#123;firstName?html&#125;</span><br><span class="line">Last name:$&#123;lastName?html&#125;</span><br><span class="line">Maiden name:$&#123;maidenName?html&#125;</span><br></pre></td></tr></table></figure><p>escape指令在解析模板时起作用而不是在运行时起作用,除此之外,escape指令也嵌套使用,子escape继承父escape的规则,如下例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;#escape x as x?html&gt;</span><br><span class="line">Customer Name:$&#123;customerName&#125;</span><br><span class="line">Items to ship;</span><br><span class="line">&lt;#escape x as itemCodeToNameMap[x]&gt;</span><br><span class="line">   $&#123;itemCode1&#125;</span><br><span class="line">   $&#123;itemCode2&#125;</span><br><span class="line">   $&#123;itemCode3&#125;</span><br><span class="line">   $&#123;itemCode4&#125;</span><br><span class="line">&lt;/#escape&gt;</span><br><span class="line">&lt;/#escape&gt;</span><br><span class="line">上面的代码类似于:</span><br><span class="line">Customer Name:$&#123;customerName?html&#125;</span><br><span class="line">Items to ship;</span><br><span class="line">$&#123;itemCodeToNameMap[itemCode1]?html&#125;</span><br><span class="line">$&#123;itemCodeToNameMap[itemCode2]?html&#125;</span><br><span class="line">$&#123;itemCodeToNameMap[itemCode3]?html&#125;</span><br><span class="line">$&#123;itemCodeToNameMap[itemCode4]?html&#125;</span><br></pre></td></tr></table></figure><p>对于放在escape指令中所有的插值而言,这此插值将被自动加上escape表达式,如果需要指定escape指令中某些插值无需添加escape表达式,则应该使用noescape指令,放在noescape指令中的插值将不会添加escape表达式.</p><p><em>assign指令</em></p><p>assign指令在前面已经使用了多次,它用于为该模板页面创建或替换一个顶层变量,assign指令的用法有多种,包含创建或替换一个顶层变量,或者创建或替换多个变量等,它的最简单的语法如下:&lt;#assign name=value [in namespacehash]&gt;,这个用法用于指定一个名为name的变量,该变量的值为value,此外,FreeMarker允许在使用assign指令里增加in子句,in子句用于将创建的name变量放入namespacehash命名空间中.</p><p>assign指令还有如下用法:&lt;#assign name1=value1 name2=value2 … nameN=valueN [in namespacehash]&gt;,这个语法可以同时创建或替换多个顶层变量,此外,还有一种复杂的用法,如果需要创建或替换的变量值是一个复杂的表达式,则可以使用如下语法格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign x&gt;</span><br><span class="line">&lt;#list [&quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;, &quot;星期天&quot;] as n&gt;</span><br><span class="line">$&#123;n&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line">&lt;/#assign&gt;</span><br><span class="line">$&#123;x&#125;</span><br><span class="line">上面的代码将产生如下输出:星期一 星期二 星期三 星期四 星期五 星期六 星期天</span><br></pre></td></tr></table></figure><p>虽然assign指定了这种复杂变量值的用法,但是我们也不要滥用这种用法,如下例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#assign x&gt;Hello $&#123;user&#125;!&lt;/#assign&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以上代码改为如下写法更合适:&lt;#assign x=&quot;Hello $&#123;user&#125;!&quot;&gt;</span><br></pre></td></tr></table></figure><p><em>setting指令</em></p><p>该指令用于设置FreeMarker的运行环境,该指令的语法格式如下:&lt;#setting name=value&gt;,在这个格式中,name的取值范围包含如下几个:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">locale:该选项指定该模板所用的国家/语言选项</span><br><span class="line">number_format:指定格式化输出数字的格式</span><br><span class="line">boolean_format:指定两个布尔值的语法格式,默认值是true,false</span><br><span class="line">date_format,time_format,datetime_format:指定格式化输出日期的格式</span><br><span class="line">time_zone:设置格式化输出日期时所使用的时区</span><br></pre></td></tr></table></figure><p><em>macro , nested , return指令</em></p><p>macro可以用于实现自定义指令,通过使用自定义指令,可以将一段模板片段定义成一个用户指令,使用macro指令的语法格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro name param1 param2 ... paramN&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#nested loopvar1, loopvar2, ..., loopvarN&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#return&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure><p>在上面的格式片段中,包含了如下几个部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name:name属性指定的是该自定义指令的名字,使用自定义指令时可以传入多个参数</span><br><span class="line">paramX:该属性就是指定使用自定义指令时报参数,使用该自定义指令时,必须为这些参数传入值</span><br><span class="line">nested指令:nested标签输出使用自定义指令时的中间部分</span><br><span class="line">nested指令中的循环变量:这此循环变量将由macro定义部分指定,传给使用标签的模板</span><br><span class="line">return指令:该指令可用于随时结束该自定义指令.</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro book&gt;   //定义一个自定义指令</span><br><span class="line">j2ee</span><br><span class="line">&lt;/#macro&gt;</span><br><span class="line">&lt;@book /&gt;    //使用刚才定义的指令</span><br><span class="line">上面的代码输出结果为:j2ee</span><br></pre></td></tr></table></figure><p>在上面的代码中,可能很难看出自定义标签的用处,因为我们定义的book指令所包含的内容非常简单,实际上,自定义标签可包含非常多的内容,从而可以实现更好的代码复用.此外,还可以在定义自定义指令时,为自定义指令指定参数,看如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro book booklist&gt;     //定义一个自定义指令booklist是参数</span><br><span class="line">&lt;#list booklist as book&gt;</span><br><span class="line">   $&#123;book&#125;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br><span class="line">&lt;@book booklist=[&quot;spring&quot;,&quot;j2ee&quot;] /&gt;   //使用刚刚定义的指令</span><br></pre></td></tr></table></figure><p>上面的代码为book指令传入了一个参数值,上面的代码的输出结果为:spring j2ee</p><p>不仅如此,还可以在自定义指令时使用nested指令来输出自定义指令的中间部分,看如下例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro page title&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;FreeMarker示例页面 - $&#123;title?html&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;h1&gt;$&#123;title?html&#125;&lt;/h1&gt;</span><br><span class="line">   &lt;#nested&gt;      //用于引入用户自定义指令的标签体</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure><p>上面的代码将一个HTML页面模板定义成一个page指令,则可以在其他页面中如此page指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#import &quot;/common.ftl&quot; as com&gt;     //假设上面的模板页面名为common.ftl,导入页面</span><br><span class="line">&lt;@com.page title=&quot;book list&quot;&gt;</span><br><span class="line">&lt;u1&gt;</span><br><span class="line">&lt;li&gt;spring&lt;/li&gt;</span><br><span class="line">&lt;li&gt;j2ee&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/@com.page&gt;</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出,使用macro和nested指令可以非常容易地实现页面装饰效果,此外,还可以在使用nested指令时,指定一个或多个循环变量,看如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro book&gt;</span><br><span class="line">&lt;#nested 1&gt;      //使用book指令时指定了一个循环变量值</span><br><span class="line">&lt;#nested 2&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br><span class="line">&lt;@book ;x&gt; $&#123;x&#125; .图书&lt;/@book&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当使用nested指令传入变量值时,在使用该自定义指令时,就需要使用一个占位符(如book指令后的;x).上面的代码输出文本如下:</span><br><span class="line">1 .图书    2 .图书</span><br></pre></td></tr></table></figure><p>在nested指令中使用循环变量时,可以使用多个循环变量,看如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro repeat count&gt;</span><br><span class="line">&lt;#list 1..count as x&gt;     //使用nested指令时指定了三个循环变量</span><br><span class="line">   &lt;#nested x, x/2, x==count&gt;</span><br><span class="line">&lt;/#list&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br><span class="line">&lt;@repeat count=4 ; c halfc last&gt;</span><br><span class="line">$&#123;c&#125;. $&#123;halfc&#125;&lt;#if last&gt; Last! &lt;/#if&gt;</span><br><span class="line">&lt;/@repeat&gt;</span><br><span class="line">上面的输出结果为:</span><br><span class="line">1. 0.5   2. 1   3. 1.5   4. 2 Last;</span><br></pre></td></tr></table></figure><p>return指令用于结束macro指令,一旦在macro指令中执行了return指令,则FreeMarker不会继续处理macro指令里的内容,看如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro book&gt;</span><br><span class="line">spring</span><br><span class="line">&lt;#return&gt;</span><br><span class="line">j2ee</span><br><span class="line">&lt;/#macro&gt;</span><br><span class="line">&lt;@book /&gt;</span><br></pre></td></tr></table></figure><p>上面的代码输出:spring,而j2ee位于return指令之后,不会输出.</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> FreeMarker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FreeMarker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2019/01/19/Docker/"/>
      <url>/2019/01/19/Docker/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>Docker 是一个<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339" target="_blank" rel="noopener">开源</a>的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a> 机器上，也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949" target="_blank" rel="noopener">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。</p><a id="more"></a><h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a><strong>Docker简介</strong></h3><h4 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a><strong>虚拟化</strong></h4><p>​ 在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</p><p>​ 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用</p><p>​ 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。</p><p><strong>Docker</strong></p><p>​ Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 <a href="https://github.com/docker/docker" target="_blank" rel="noopener">GitHub</a> 上进行维护。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fzbt4kh7n4j30ff056dh5.jpg" alt=""></p><p>​ Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。</p><p>​ Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。</p><p>​ 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p><p><strong>Docker特点</strong></p><p>（1）上手快。</p><p>​ 用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。</p><p>​ 随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</p><p>（2）职责的逻辑分类</p><p>​ 使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）”</p><p>（3）快速高效的开发生命周期</p><p>​ Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取。）</p><p>（4）鼓励使用面向服务的架构</p><p>​ Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）</p><p><strong>容器与虚拟机比较</strong></p><p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。</p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDgy1fzbt7kk58sj30jo0dlmxq.jpg" alt=""></p><p>与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。</p><h4 id="Docker-组件"><a href="#Docker-组件" class="headerlink" title="Docker 组件"></a><strong>Docker 组件</strong></h4><p><strong>Docker服务器与客户端</strong></p><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDgy1fzbt9d04n4j30aa0bnn03.jpg" alt=""></p><p><strong>Docker镜像与容器</strong></p><p>镜像是构建Docker的基石。用户基于镜像来运行自己的容器。镜像也是Docker生命周期中的“构建”部分。镜像是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。例如：</p><p>添加一个文件；</p><p>执行一个命令；</p><p>打开一个窗口。</p><p>也可以将镜像当作容器的“源代码”。镜像体积很小，非常“便携”，易于分享、存储和更新。</p><p>​ Docker可以帮助你构建和部署容器，你只需要把自己的应用程序或者服务打包放进容器即可。容器是基于镜像启动起来的，容器中可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中的构建或者打包阶段，而容器则是启动或者执行阶段。 容器基于镜像启动，一旦容器启动完成后，我们就可以登录到容器中安装自己需要的软件或者服务。</p><p>所以Docker容器就是：</p><p>​ 一个镜像格式；</p><p>​ 一些列标准操作；</p><p>​ 一个执行环境。</p><p>​ Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。</p><p>​ 和集装箱一样，Docker在执行上述操作时，并不关心容器中到底装了什么，它不管是web服务器，还是数据库，或者是应用程序服务器什么的。所有的容器都按照相同的方式将内容“装载”进去。</p><p>​ Docker也不关心你要把容器运到何方：我们可以在自己的笔记本中构建容器，上传到Registry，然后下载到一个物理的或者虚拟的服务器来测试，在把容器部署到具体的主机中。像标准集装箱一样，Docker容器方便替换，可以叠加，易于分发，并且尽量通用。</p><p><strong>Registry（注册中心）</strong></p><p>Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h3 id="Docker安装与启动"><a href="#Docker安装与启动" class="headerlink" title="Docker安装与启动"></a><strong>Docker安装与启动</strong></h3><p><strong>安装Docker</strong></p><p>Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。</p><p>​ 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。</p><p>​ 请直接挂载课程配套的Centos7.x镜像</p><p>（1）yum 包更新到最新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure><p>（2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>（3）设置yum源为阿里云</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>（4）安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>（5）安装后查看docker版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p><strong>设置ustc的镜像</strong></p><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</p><p><a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p>编辑该文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>在该文件中输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Docker的启动与停止</strong></p><p><strong>systemctl</strong>命令是系统服务管理器指令</p><p>启动docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>停止docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><p>重启docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>查看docker状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><p>开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>查看docker概要信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>查看docker帮助文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><h4 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a><strong>镜像相关命令</strong></h4><p><strong>查看镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>REPOSITORY：镜像名称</p><p>TAG：镜像标签</p><p>IMAGE ID：镜像ID</p><p>CREATED：镜像的创建日期（不是获取该镜像的日期）</p><p>SIZE：镜像大小</p><p>这些镜像都是存储在Docker宿主机的/var/lib/docker目录下</p><p><strong>搜索镜像</strong></p><p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><p>NAME：仓库名称</p><p>DESCRIPTION：镜像描述</p><p>STARS：用户评价，反应一个镜像的受欢迎程度</p><p>OFFICIAL：是否官方</p><p>AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</p><p><strong>拉取镜像</strong></p><p>拉取镜像就是从中央仓库中下载镜像到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure><p>例如，我要下载centos7镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><p>按镜像ID删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi `docker images -q`</span><br></pre></td></tr></table></figure><h4 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a><strong>容器相关命令</strong></h4><p><strong>查看容器</strong></p><p>查看正在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps –a</span><br></pre></td></tr></table></figure><p>查看最后一次运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps –l</span><br></pre></td></tr></table></figure><p>查看停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f status=exited</span><br></pre></td></tr></table></figure><p><strong>创建与启动容器</strong></p><p>创建容器常用的参数说明：</p><p>创建容器命令：docker run</p><p>-i：表示运行容器</p><p>-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</p><p>–name :为创建的容器命名。</p><p>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</p><p>-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</p><p>-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射</p><p>（1）交互式方式创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=容器名称 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure><p>这时我们通过ps命令查看，发现可以看到启动的容器，状态为启动状态</p><p>退出当前容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>（2）守护式方式创建容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure><p>登录守护式容器方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名称 (或者容器ID)  /bin/bash</span><br></pre></td></tr></table></figure><p><strong>停止与启动容器</strong></p><p>停止容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称（或者容器ID）</span><br></pre></td></tr></table></figure><p><strong>文件拷贝</strong></p><p>如果我们需要将文件拷贝到容器内可以使用cp命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure><p>也可以将文件从容器内拷贝出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure><p><strong>目录挂载</strong></p><p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos3 centos:7</span><br></pre></td></tr></table></figure><p>如果你共享的是多级的目录，可能会出现权限不足的提示。</p><p>这是因为CentOS7中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题</p><p><strong>查看容器IP地址</strong></p><p>我们可以通过以下命令查看容器运行的各种数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p>也可以直接执行下面的命令直接输出IP地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; 容器名称（容器ID）</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><p>删除指定的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称（容器ID）</span><br></pre></td></tr></table></figure><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a><strong>应用部署</strong></h3><h4 id="MySQL部署"><a href="#MySQL部署" class="headerlink" title="MySQL部署"></a><strong>MySQL部署</strong></h4><p>（1）拉取mysql镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos/mysql-57-centos7</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br></pre></td></tr></table></figure><p>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</p><p>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的登陆密码</p><p>（3）远程登录mysql</p><p>连接宿主机的IP ,指定端口为33306</p><h4 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a><strong>tomcat部署</strong></h4><p>（1）拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><p>创建容器 -p表示地址映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 </span><br><span class="line">-v /usr/local/webapps:/usr/local/tomcat/webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure><h4 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a><strong>Nginx部署</strong></h4><p>（1）拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><p>（2）创建Nginx容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><h4 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a><strong>Redis部署</strong></h4><p>（1）拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure><p>（2）创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h3 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a><strong>迁移与备份</strong></h3><p><strong>容器保存为镜像</strong></p><p>我们可以通过以下命令将容器保存为镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure><p><strong>镜像备份</strong></p><p>我们可以通过以下命令将镜像保存为tar 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure><p><strong>镜像恢复与迁移</strong></p><p>我们可以通过以下命令将镜像保存为tar 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure><p><strong>镜像恢复与迁移</strong></p><p>首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure><p>-i 输入的文件</p><p>执行后再次查看镜像，可以看到镜像已经恢复</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><strong>Dockerfile</strong></h3><p>Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p><p>1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；</p><p>2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；</p><p>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table><h4 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a><strong>使用脚本创建镜像</strong></h4><p>步骤：</p><p>（1）创建目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir –p /usr/local/dockerjdk8</span><br></pre></td></tr></table></figure><p>（2）下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录</p><p>（3）创建文件Dockerfile <code>vi Dockerfile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#依赖镜像名称和ID</span><br><span class="line">FROM centos:7</span><br><span class="line">#指定镜像创建者信息</span><br><span class="line">MAINTAINER SWUSHXW</span><br><span class="line">#切换工作目录</span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir  /usr/local/java</span><br><span class="line">#ADD 是相对路径jar,把java添加到容器中</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/</span><br><span class="line"></span><br><span class="line">#配置java环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>（4）执行命令构建镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&apos;jdk1.8&apos; .</span><br></pre></td></tr></table></figure><p>注意后边的空格和点，不要省略</p><p>（5）查看镜像是否建立完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="Docker私有仓库"><a href="#Docker私有仓库" class="headerlink" title="Docker私有仓库"></a><strong>Docker私有仓库</strong></h3><h4 id="私有仓库搭建与配置"><a href="#私有仓库搭建与配置" class="headerlink" title="私有仓库搭建与配置"></a><strong>私有仓库搭建与配置</strong></h4><p>（1）拉取私有仓库镜像（此步省略）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><p>（2）启动私有仓库容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=registry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>（3）打开浏览器 输入地址<a href="http://192.168.184.141:5000/v2/_catalog" target="_blank" rel="noopener">http://192.168.184.141:5000/v2/_catalog</a>看到<code>{&quot;repositories&quot;:[]}</code> 表示私有仓库搭建成功并且内容为空</p><p>（4）修改daemon.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>添加以下内容，保存退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.184.141:5000&quot;]&#125;</span><br></pre></td></tr></table></figure><p>此步用于让 docker信任私有仓库地址</p><p>（5）重启docker 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h4 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a><strong>镜像上传至私有仓库</strong></h4><p>（1）标记此镜像为私有仓库的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag jdk1.8 192.168.184.141:5000/jdk1.8</span><br></pre></td></tr></table></figure><p>（2）再次启动私服容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p>（3）上传标记的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.184.141:5000/jdk1.8</span><br></pre></td></tr></table></figure><p><strong><em>文章出处：互联网，具体不详</em></strong></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js</title>
      <link href="/2019/01/18/Vue/"/>
      <url>/2019/01/18/Vue/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络程序设计</title>
      <link href="/2017/05/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/05/19/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread/多线程</title>
      <link href="/2017/05/13/Thread/"/>
      <url>/2017/05/13/Thread/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2017/04/27/%E5%8F%8D%E5%B0%84/"/>
      <url>/2017/04/27/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Reflect </tag>
            
            <tag> Class </tag>
            
            <tag> 反射机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O流</title>
      <link href="/2017/04/20/IO%E6%B5%81/"/>
      <url>/2017/04/20/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> I/O流 </tag>
            
            <tag> Reder </tag>
            
            <tag> Writer </tag>
            
            <tag> InputStream </tag>
            
            <tag> OutputStream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2017/04/17/%E5%BC%82%E5%B8%B8/"/>
      <url>/2017/04/17/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p><a id="more"></a><h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a><strong>异常体系结构</strong></h3><p><img src="http://www.runoob.com/wp-content/uploads/2013/12/12-130Q1234I6223.jpg" alt=""></p><p>异常的根类是java.lang.Throwable ，其下有两个子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Error </span><br><span class="line">java.lang.Exception</span><br></pre></td></tr></table></figure><p>平常所说的异常指java.lang.Exception 。</p><p>Throwable体系：<br>​ |— Error:严重错误Error，无法通过处理的错误，只能事先避免。<br>​ |— Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。</p><p>Throwable中的常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span> :打印异常的详细信息。</span></span><br><span class="line"><span class="function"><span class="comment">//包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> :获取发生异常的原因。</span></span><br><span class="line"><span class="function"><span class="comment">//提示给用户的时候,就提示错误原因。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> :获取异常的类型和异常描述信息<span class="params">(基本不用)</span>。</span></span><br></pre></td></tr></table></figure><p>在我们开发过程中，遇到异常最推荐的做法是，将异常的简单类名拷贝到API中去查，以便理解。</p><p><img src="http://www.west.cn/info/upload/20190111/gzu2a0wkxw4.jpg" alt=""></p><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a><strong>异常的处理</strong></h3><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p><h4 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a><strong>抛出异常throw</strong></h4><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方<br>法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的<br>数据进来。这时需要使用抛出异常的方式来告诉调用者。<br>在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</li><li>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw<br>就可以完成。throw 异常对象。<br>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</li></ol><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"访问数据不存在"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组下标越界"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">            <span class="comment">//判断 索引是否越界</span></span><br><span class="line">            <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length‐<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">                    这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"数组角标越界了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。<br>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws<br>声明处理。</p><h4 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a><strong>声明异常throws</strong></h4><p>声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲<br>解该方式），那么必须通过throws进行声明，让调用者去处理。<br>关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).<br>声明异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>…&#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    read(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件</span></span><br><span class="line">            <span class="comment">// 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗<br>号隔开。</p><h4 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a><strong>捕获异常try…catch</strong></h4><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p>try-catch的方式就是捕获异常。</p><ul><li>捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//编写可能会出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    <span class="comment">//处理异常的代码</span></span><br><span class="line">    <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try：该代码块中编写可能产生异常的代码。<br>catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><p>注意:try和catch都不能单独使用,必须连用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">        read(<span class="string">"b.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">        <span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">        System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 我们 当前的这个方法中 有异常 有编译期异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件</span></span><br><span class="line">        <span class="comment">// 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取异常信息：<br>Throwable类中定义了一些查看方法:</p><ul><li>public String getMessage() :获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</li><li>public String toString() :获取异常的类型和异常描述信息(不用)。</li><li>public void printStackTrace() :打印异常的跟踪栈信息并输出到控制台。</li></ul><p>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</p><h4 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a><strong>finally 代码块</strong></h4><p>finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行<br>不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。<br>什么时候的代码必须最终执行？<br>当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>....<span class="keyword">finally</span>:自身需要处理异常,最终还得关闭资源。</span><br></pre></td></tr></table></figure><p>注意:finally不能单独使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryCatchDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        read(<span class="string">"a.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">//抓取到的是编译期异常 抛出去的是运行期</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"不管程序怎样，这里都将会被执行。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 我们 当前的这个方法中 有异常 有编译期异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件</span></span><br><span class="line">            <span class="comment">// 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p><h3 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a><strong>异常注意事项</strong></h3><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//编写可能会出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A e)&#123; 当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line"><span class="comment">//处理异常的代码</span></span><br><span class="line"><span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B e)&#123; 当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line"><span class="comment">//处理异常的代码</span></span><br><span class="line"><span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异<br>常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p><ul><li>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</li><li>如果finally有return语句,永远返回finally中的结果,避免该情况。</li><li>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</li><li>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><strong>自定义异常</strong></h3><p>概述：</p><p>为什么需要自定义异常类:<br>​ 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。<br>​ 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p><p>什么是自定义异常类:</p><ol><li>在开发中根据自己业务的异常情况来定义异常类.</li><li>自定义一个业务逻辑异常: RegisterException。一个注册异常类。</li></ol><p>异常类如何定义:</p><ol><li>自定义一个编译期异常: 自定义类 并继承于java.lang.Exception 。</li><li>自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException 。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg：</span></span><br><span class="line"><span class="comment">//要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</span></span><br><span class="line"><span class="comment">//首先定义一个登陆异常类RegisterException：</span></span><br><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 空参构造</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">"bill"</span>,<span class="string">"hill"</span>,<span class="string">"jill"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">"nill"</span>);</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">        <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">"亲"</span>+name+<span class="string">"已经被注册了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a><strong>常见异常</strong></h3><p><strong><em>参考博文：<a href="https://blog.csdn.net/qq_33578833/article/details/78780364" target="_blank" rel="noopener">https://blog.csdn.net/qq_33578833/article/details/78780364</a></em></strong></p><ul><li>ArithmeticExecption|算术异常类.</li><li>NullPointerException|空指针异常类.</li><li>ClassCastException|类型强制转换异常.</li><li>NegativeArrayException|数组负下标异常.</li><li>ArrayIndexOutOfBoundsException|数组下标越界异常.</li><li>SecturityException|违背安全原则异常.</li><li>EOFException|文件已结束异常.</li><li>FileNotFoundException|文件未找到异常.</li><li>NumberFormatException|字符串转换为数字异常.</li><li>SQLException|操作数据库异常.</li><li>IOException|输入输出异常.</li><li>NoSuchMethodException|方法未找到异常.</li><li>java.lang.AbstractMethodError|抽象方法错误。当应用试图调用抽象方法时抛出.</li><li>java.lang.AssertionError|断言错。用来指示一个断言失败的情况.</li><li>java.lang.ClassCircularityError|类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常.</li><li><p>java.lang.ClassFormatError|类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出.</p></li><li><p>java.lang.Error|错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况.</p></li><li>java.lang.ExceptionInInitializerError|初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段.</li><li>java.lang.IllegalAccessError|违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常.</li><li>java.lang.IncompatibleClassChangeError|不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误.</li><li>java.lang.InstantiationError|实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</li><li><p>java.lang.InternalError|内部错误。用于指示Java虚拟机发生了内部错误.</p></li><li><p>java.lang.LinkageError|链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况.</p></li><li>java.lang.NoClassDefFoundError|未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误.</li><li>java.lang.NoSuchFieldError|域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误.</li><li><p>java.lang.NoSuchMethodError|方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误.</p></li><li><p>java.lang.OutOfMemoryError|内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误.</p></li><li>java.lang.StackOverflowError|堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误.</li><li>java.lang.ThreadDeath|线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束.</li><li>java.lang.UnknownError|未知错误。用于指示Java虚拟机发生了未知严重错误的情况.</li><li>java.lang.UnsatisfiedLinkError|未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出.</li><li>java.lang.UnsupportedClassVersionError|不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误.</li><li>java.lang.VerifyError|验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误.</li><li>java.lang.VirtualMachineError|虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况.</li><li>java.lang.ArithmeticException|算术条件异常。譬如：整数除零等.</li><li>java.lang.ArrayIndexOutOfBoundsException|数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出.</li><li><p>java.lang.ArrayStoreException|数组存储异常。当向数组中存放非数组声明类型对象时抛出.</p></li><li><p>java.lang.ClassCastException|造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。</p></li><li>java.lang.ClassNotFoundException|不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li><li>java.lang.CloneNotSupportedException|支持克隆异常。当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。</li><li>java.lang.EnumConstantNotPresentException|举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。</li><li>java.lang.Exception|异常。用以描述应用程序希望捕获的情况。</li><li>java.lang.IllegalAccessException|法的访问异常。当应用试图通过反射方式创建某个类的实例、访问该类属性、调用该类方法，而当时又无法访问类的、属性的、方法的或构造方法的定义时抛出该异常。</li><li>java.lang.IllegalMonitorStateException|法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。</li><li>java.lang.IllegalStateException|法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。</li><li>java.lang.IllegalThreadStateException|法的线程状态异常。当县城尚未处于某个方法的合法调用状态，而调用了该方法时，抛出异常。</li><li>java.lang.IndexOutOfBoundsException|引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</li><li>java.lang.InstantiationException|例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</li><li>java.lang.InterruptedException|中止异常。当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。</li><li>java.lang.NegativeArraySizeException|组大小为负值异常。当使用负数大小值创建数组时抛出该异常。|ava.lang.NoSuchFieldException|性不存在异常。当访问某个类的不存在的属性时抛出该异常。</li><li>java.lang.NoSuchMethodException|法不存在异常。当访问某个类的不存在的方法时抛出该异常。</li><li>java.lang.NullPointerException|指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</li><li><p>java.lang.NumberFormatException|字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</p></li><li><p>java.lang.RuntimeException|行时异常。是所有Java虚拟机正常操作期间可以被抛出的异常的父类。|ava.lang.SecurityException|全异常。由安全管理器抛出，用于指示违反安全情况的异常。</p></li><li>java.lang.StringIndexOutOfBoundsException|符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li><li><p>java.lang.TypeNotPresentException|型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。</p></li><li><p>java.lang.UnsupportedOperationException|支持的方法异常。指明请求的方法不被支持情况的异常。</p></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 异常 </tag>
            
            <tag> Exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架(三)-HashMap底层实现原理</title>
      <link href="/2017/04/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%B8%89)-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2017/04/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%B8%89)-HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>先来了解哈希表，什么是哈希表呢？<br>在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。 但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈 希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找 时间。</p><a id="more"></a><h3 id="HashMap的底层实现原理"><a href="#HashMap的底层实现原理" class="headerlink" title="HashMap的底层实现原理"></a>HashMap的底层实现原理</h3><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a><strong>HashMap的数据结构</strong></h4><p><a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>中有数组和链表来实现对数据的存储，但这两者基本上是两个极端。</p><p>数组：</p><p>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</p><p>链表：</p><p>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。<strong>链表</strong>的特点是：寻址困难，插入和删除容易。</p><p>哈希表：</p><p>那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p><p>哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“<strong>链表的数组</strong>” ，如图：</p><p><img src="https://app.yinxiang.com/shard/s33/nl/22781464/2ed59691-d930-4b45-b5a2-1dc04d88fd64/res/023bf655-674f-496d-95d6-3c65a080eddf/SouthEast?resizeSmall&amp;width=832" alt=""></p><p><img src="https://app.yinxiang.com/shard/s33/nl/22781464/2ed59691-d930-4b45-b5a2-1dc04d88fd64/res/7a5715e9-f6fc-41cf-b019-639881d3a527/SouthEast?resizeSmall&amp;width=832" alt=""></p><p>​ 从上图我们可以发现哈希表是由<strong>数组+链表</strong>组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点。那么这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p><p>​ HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。</p><p>​ 首先HashMap里面实现一个静态内部类Entry，其重要的属性有 <em>key , value, next</em>，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean，我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br></pre></td></tr></table></figure><h4 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a><strong>HashMap的存取实现</strong></h4><p>既然是线性数组，为什么能随机存取？这里HashMap用了一个小<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">算法</a>，大致是这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储时:</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode(); <span class="comment">// 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值</span></span><br><span class="line"><span class="keyword">int</span> index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值时:</span></span><br><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"><span class="keyword">int</span> index = hash % Entry[].length;</span><br><span class="line"><span class="keyword">return</span> Entry[index];</span><br></pre></td></tr></table></figure><p>1）<em>put</em></p><p>疑问：如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？</p><p>这里HashMap里面用到链式数据结构的一个概念。上面我们提到过Entry类里面有一个next属性，作用是指向下一个Entry。打个比方， 第一个键值对A进来，通过计算其key的hash得到的index=0，记做:Entry[0] = A。一会后又进来一个键值对B，通过计算其index也等于0，现在怎么办？HashMap会这样做:<em>B.next = A</em>,Entry[0] = B,如果又进来C,index也等于0,那么<em>C.next = B</em>,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。<strong>也就是说数组中存储的是最后插入的元素。</strong>到这里为止，HashMap的大致实现，我们应该已经清楚了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value); <span class="comment">//null总是放在数组的第一个链表中</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">//如果key在链表中已存在，则替换为新value</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e); <span class="comment">//参数e, 是Entry.next</span></span><br><span class="line">    <span class="comment">//如果size超过threshold，则扩充table大小。再散列</span></span><br><span class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然HashMap里面也包含一些优化方面的实现，这里也说一下。比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因子，随着map的size越来越大，Entry[]会以一定的规则加长长度。</p><p>2）<em>get</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="comment">//先定位到数组元素，再遍历该元素处的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）<em>null key的存取</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//null key总是存放在Entry[]数组的第一个元素。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4）<em>确定数组index：hashcode % table.length取模</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap存取时，都需要计算当前key应该对应Entry[]数组哪个元素，即计算数组下标；算法如下：</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>5）<em>table初始大小</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        .....         <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意table初始大小并不是构造函数中的initialCapacity！！</strong></p><p><strong>而是 &gt;= initialCapacity的2的n次幂！！！！</strong></p><p>——为什么这么设计呢？——</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">来看看哈希冲突（来源：https://www.cnblogs.com/chengxiao/p/6059914.html）</span><br></pre></td></tr></table></figure><p>哈希冲突（哈希碰撞）<br>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，</p><h4 id="解决hash冲突（碰撞）的办法"><a href="#解决hash冲突（碰撞）的办法" class="headerlink" title="解决hash冲突（碰撞）的办法"></a><strong>解决hash冲突（碰撞）的办法</strong></h4><ol><li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li><li>再哈希法</li><li><strong>链地址法</strong></li><li>建立一个公共溢出区</li></ol><p><a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>中hashmap的解决办法就是采用的链地址法。</p><h4 id="再散列rehash过程"><a href="#再散列rehash过程" class="headerlink" title="再散列rehash过程"></a><strong>再散列rehash过程</strong></h4><p>当哈希表的容量超过默认容量时，必须调整table的大小。当容量已经达到最大可能值时，那么该方法就将容量调整到Integer.MAX_VALUE返回，这时，需要创建一张新表，将原表的映射到新表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">     * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">     * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">     * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">     *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">     *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">     *        is irrelevant).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="comment">//重新计算index</span></span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><em>文章出处：<a href="https://www.cnblogs.com/holyshengjie/p/6500463.html" target="_blank" rel="noopener">https://www.cnblogs.com/holyshengjie/p/6500463.html</a></em></strong></p><p><strong><em>参考博文：<a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6059914.html</a></em></strong></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> HaspMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架(二)-单列&amp;双列集合底层数据结构</title>
      <link href="/2017/04/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%BA%8C)-%E6%B5%85%E8%B0%88%E5%8D%95%E5%88%97&amp;%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2017/04/12/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%BA%8C)-%E6%B5%85%E8%B0%88%E5%8D%95%E5%88%97&amp;%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>集合的底层数据结构与选用规则</p><a id="more"></a><h3 id="集合底层数据结构"><a href="#集合底层数据结构" class="headerlink" title="集合底层数据结构"></a><strong>集合底层数据结构</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    Collection(单列集合)</span><br><span class="line">        List(有序,可重复)</span><br><span class="line">            ArrayList</span><br><span class="line">                底层数据结构是数组,查询快,增删慢</span><br><span class="line">                线程不安全,效率高</span><br><span class="line">            Vector</span><br><span class="line">                底层数据结构是数组,查询快,增删慢</span><br><span class="line">                线程安全,效率低</span><br><span class="line">            LinkedList</span><br><span class="line">                底层数据结构是链表,查询慢,增删快</span><br><span class="line">                线程不安全,效率高</span><br><span class="line">        Set(无序,唯一)</span><br><span class="line">            HashSet</span><br><span class="line">                底层数据结构是哈希表。</span><br><span class="line">                哈希表依赖两个方法：hashCode()和equals()</span><br><span class="line">                执行顺序：</span><br><span class="line">                    首先判断hashCode()值是否相同</span><br><span class="line">                        是：继续执行equals(),看其返回值</span><br><span class="line">                            是<span class="keyword">true</span>:说明元素重复，不添加</span><br><span class="line">                            是<span class="keyword">false</span>:就直接添加到集合</span><br><span class="line">                        否：就直接添加到集合</span><br><span class="line">                最终：</span><br><span class="line">                    自动生成hashCode()和equals()即可</span><br><span class="line">LinkedHashSet</span><br><span class="line">                底层数据结构由链表和哈希表组成。</span><br><span class="line">                由链表保证元素有序。</span><br><span class="line">                由哈希表保证元素唯一。</span><br><span class="line">        TreeSet</span><br><span class="line">            底层数据结构是红黑树。(是一种自平衡的二叉树)</span><br><span class="line">            如何保证元素唯一性呢?</span><br><span class="line">                根据比较的返回值是否是<span class="number">0</span>来决定</span><br><span class="line">            如何保证元素的排序呢?</span><br><span class="line">                两种方式</span><br><span class="line">                    自然排序(元素具备比较性)</span><br><span class="line">                        让元素所属的类实现Comparable接口</span><br><span class="line">                    比较器排序(集合具备比较性)</span><br><span class="line">                        让集合接收一个Comparator的实现类对象</span><br><span class="line">Map(双列集合)</span><br><span class="line">    A:Map集合的数据结构仅仅针对键有效，与值无关。</span><br><span class="line">    B:存储的是键值对形式的元素，键唯一，值可重复。</span><br><span class="line">    </span><br><span class="line">    HashMap</span><br><span class="line">        底层数据结构是哈希表。线程不安全，效率高</span><br><span class="line">            哈希表依赖两个方法：hashCode()和equals()</span><br><span class="line">            执行顺序：</span><br><span class="line">                首先判断hashCode()值是否相同</span><br><span class="line">                    是：继续执行equals(),看其返回值</span><br><span class="line">                        是<span class="keyword">true</span>:说明元素重复，不添加</span><br><span class="line">                        是<span class="keyword">false</span>:就直接添加到集合</span><br><span class="line">                    否：就直接添加到集合</span><br><span class="line">            最终：</span><br><span class="line">                自动生成hashCode()和equals()即可</span><br><span class="line">        LinkedHashMap</span><br><span class="line">            底层数据结构由链表和哈希表组成。</span><br><span class="line">                由链表保证元素有序。</span><br><span class="line">                由哈希表保证元素唯一。</span><br><span class="line">    Hashtable</span><br><span class="line">        底层数据结构是哈希表。线程安全，效率低</span><br><span class="line">            哈希表依赖两个方法：hashCode()和equals()</span><br><span class="line">            执行顺序：</span><br><span class="line">                首先判断hashCode()值是否相同</span><br><span class="line">                    是：继续执行equals(),看其返回值</span><br><span class="line">                        是<span class="keyword">true</span>:说明元素重复，不添加</span><br><span class="line">                        是<span class="keyword">false</span>:就直接添加到集合</span><br><span class="line">                    否：就直接添加到集合</span><br><span class="line">            最终：</span><br><span class="line">                自动生成hashCode()和equals()即可</span><br><span class="line">    TreeMap</span><br><span class="line">        底层数据结构是红黑树。(是一种自平衡的二叉树)</span><br><span class="line">            如何保证元素唯一性呢?</span><br><span class="line">                根据比较的返回值是否是<span class="number">0</span>来决定</span><br><span class="line">            如何保证元素的排序呢?</span><br><span class="line">                两种方式</span><br><span class="line">                    自然排序(元素具备比较性)</span><br><span class="line">                        让元素所属的类实现Comparable接口</span><br><span class="line">                    比较器排序(集合具备比较性)</span><br><span class="line">                        让集合接收一个Comparator的实现类对象</span><br></pre></td></tr></table></figure><h3 id="关于集合选用规则"><a href="#关于集合选用规则" class="headerlink" title="关于集合选用规则"></a><strong>关于集合选用规则</strong></h3><pre><code>是否是键值对象形式:    是：Map        键是否需要排序:            是：TreeMap            否：HashMap        未知，使用HashMap。    否：Collection        元素是否唯一:            是：Set                元素是否需要排序:                    是：TreeSet                    否：HashSet                未知，使用HashSet            否：List                要安全吗:                    是：Vector                    否：ArrayList或者LinkedList                        增删多：LinkedList                        查询多：ArrayList                    未知，使用ArrayList        未知，使用ArrayList</code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> List </tag>
            
            <tag> Map </tag>
            
            <tag> Set </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架(一)</title>
      <link href="/2017/04/11/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%B8%80)/"/>
      <url>/2017/04/11/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>集合是java中提供的一种容器，可以用来存储多个数据，集合类存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用（reference)。 集合类型主要有3种：set(集）、list(列表）和map(映射)。 集合接口分为：Collection和Map，list、set实现了Collection接口。</p><a id="more"></a><p>在此多啰嗦一点，前面文章提到数组，数组与集合都是容器，那他们之间到底有什么区别呢？区别主要分一下两点（在实际开发中灵活运用，大多数使用集合）</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a><strong>集合框架</strong></h3><p>来一张集合框架图（图片来源：<a href="https://liujiacai.net/blog/2015/09/01/java-collection-overview/）" target="_blank" rel="noopener">https://liujiacai.net/blog/2015/09/01/java-collection-overview/）</a></p><p><img src="https://img.alicdn.com/imgextra/i4/581166664/TB21HYoeVXXXXaLXXXXXXXXXXXX_!!581166664.jpeg" alt="集合框架图"></p><p>常用四个接口的区别：</p><p>1、collection:存储不唯一、无序的数据；</p><p>2、list：存储有序的、不唯一的数据；</p><p>3、set：存储无序的、唯一的数据；</p><p>4、Map：以键值对的形式存储数据，以键取值。键不能重复、值可以重复。</p><h4 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h4><p>是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用<br>的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li>public boolean add(E e) ： 把给定的对象添加到当前集合中 。</li><li>public void clear() :清空集合中所有的元素。</li><li>public boolean remove(E e) : 把给定的对象在当前集合中删除。</li><li>public boolean contains(E e) : 判断当前集合中是否包含给定的对象。</li><li>public boolean isEmpty() : 判断当前集合是否为空。</li><li>public int size() : 返回集合中元素的个数。</li><li>public Object[] toArray() : 把集合中的元素，存储到数组中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建集合对象</span></span><br><span class="line">        <span class="comment">// 使用多态形式</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 使用方法</span></span><br><span class="line">        <span class="comment">// 添加功能 boolean add(String s)</span></span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">        <span class="comment">// boolean contains(E e) 判断o是否在集合中存在</span></span><br><span class="line">        System.out.println(<span class="string">"判断 str1 是否在集合中"</span>+coll.contains(<span class="string">"str1"</span>));</span><br><span class="line">        <span class="comment">//boolean remove(E e) 删除在集合中的o元素</span></span><br><span class="line">        System.out.println(<span class="string">"删除str2："</span>+coll.remove(<span class="string">"str2"</span>));</span><br><span class="line">        System.out.println(<span class="string">"操作之后集合中元素:"</span>+coll);</span><br><span class="line">        <span class="comment">// size() 集合中有几个元素</span></span><br><span class="line">        System.out.println(<span class="string">"集合中有"</span>+coll.size()+<span class="string">"个元素"</span>);</span><br><span class="line">        <span class="comment">// Object[] toArray()转换成一个Object数组</span></span><br><span class="line">        Object[] objects = coll.toArray();</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">        System.out.println(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// void clear() 清空集合</span></span><br><span class="line">        coll.clear();</span><br><span class="line">        System.out.println(<span class="string">"集合中内容为："</span>+coll);</span><br><span class="line">        <span class="comment">// boolean isEmpty() 判断是否为空</span></span><br><span class="line">        System.out.println(coll.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a><strong>Iterator迭代器</strong></h4><p><strong>Iterator接口</strong></p><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接 口 java.util.Iterator 。 Iterator 接口也是Java集合中的一员，但它 与 Collection 、 Map 接口有所不同， Collection 接口与 Map 接口主要用于存储元素， 而 Iterator 主要用于迭代访问（即遍历） Collection 中的元素，因此 Iterator 对象也 被称为迭代器。<br>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取 迭代器的方法：</p><ul><li>public Iterator iterator() : 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p>迭代的概念：</p><p>即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有 元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把 集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><p>Iterator接口的常用方法如下：</p><ul><li>public E next() :返回迭代的下一个元素。</li><li>public boolean hasNext() :如果仍有元素可以迭代，则返回 true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历 每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">// 泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">        String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代器的实现原理</strong></p><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素。</p><p>首先通过调用集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。</p><p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><p>当然，迭代器在开发中基本不用，一般使用增强for，在学习阶段也是必须了解的内容。</p><p><strong>增强for</strong></p><p>增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数<br>组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合<br>中的元素进行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 : Collection集合or数组)&#123;</span><br><span class="line"><span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进<br>行增删操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg1</span></span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBForDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">87</span>&#125;;</span><br><span class="line">        <span class="comment">//使用增强for遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;<span class="comment">//a代表数组中的每个元素</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg2</span></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NBFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        coll.add(<span class="string">"str1"</span>);</span><br><span class="line">        coll.add(<span class="string">"str2"</span>);</span><br><span class="line">        coll.add(<span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//使用增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s :coll)&#123;<span class="comment">//接收变量s代表 代表被遍历到的集合元素</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a><strong>List集合</strong></h4><p>List集合包括List接口以及List接口接口的所有实现类，List集合中的元素允许重复，各元素的顺序就是对象插入的顺序，类似Java数组，用户可通过使用索引来访问集合中的元素。</p><h5 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><strong>List接口</strong></h5><p>java.util.List 接口继承自Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了List 接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><p>List接口特点</p><ol><li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、<br>22、33的顺序完成的）。</li><li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li><li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li></ol><p>List接口中常用方法：</p><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操<br>作集合的特有方法，如下：</p><ul><li>public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。</li><li>public E get(int index) :返回集合中指定位置的元素。</li><li>public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li>public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List的子类</p><h5 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a><strong>ArrayList集合</strong></h5><p>java.util.ArrayList 集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList 是最常用的集合。</p><h5 id="LinkedList集合："><a href="#LinkedList集合：" class="headerlink" title="LinkedList集合："></a><strong>LinkedList集合：</strong></h5><p>java.util.LinkedList 集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDgy1fz5f1r4fuzj30vb0f8tak.jpg" alt="LinkedList "></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方<br>法我们作为了解即可：</p><ul><li>public void addFirst(E e) :将指定元素插入此列表的开头。</li><li>public void addLast(E e) :将指定元素添加到此列表的结尾。</li><li>public E getFirst() :返回此列表的第一个元素。</li><li>public E getLast() :返回此列表的最后一个元素。</li><li>public E removeFirst() :移除并返回此列表的第一个元素。</li><li>public E removeLast() :移除并返回此列表的最后一个元素。</li><li>public E pop() :从此列表所表示的堆栈处弹出一个元素。</li><li>public void push(E e) :将元素推入此列表所表示的堆栈。</li><li>public boolean isEmpty() ：如果列表不包含元素，则返回true。</li></ul><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><strong>Vector</strong></h5><p>对于Vector，它是jdk1.0就留下来的，它和ArrayList是类似的，不同点就是，它是线程安全的，在多线程的环境下使用其可能有好处，但是非多线程情况下使用效率会很低。</p><h4 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a><strong>Set集合</strong></h4><p>Set集合中的对象不按特定的方式排序，只是简单的把对象加入集合中，但Set集合中不能包含重复对象，Set集合由Set接口和Set接口的实现类组成，Set接口继承了Collection接口，因此包含Collection的所有方法。</p><h5 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a><strong>set接口</strong></h5><p>java.util.Set 接口和java.util.List 接口一样，同样继承自Collection 接口，它与Collection 接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比Collection 接口更加严格了。与List 接口不同的是， Set 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p>Set 集合有多个子类，这里我们介绍其中的java.util.HashSet 、java.util.LinkedHashSet 这两个集合。其他不常用。</p><p>java.util.HashSet 是Set 接口的一个实现类，它所存储的元素是不可重复的，并且元素都是无序的(即存取顺序<br>不一致)。java.util.HashSet 底层的实现其实是一个java.util.HashMap 支持，后面会将HashMap。</p><p>HashSet 是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于： hashCode 与equals 方法。</p><h5 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a><strong>HashSet集合存储数据的结构（哈希表）</strong></h5><p>什么是哈希表呢？<br>在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。<br>但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈<br>希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找<br>时间。<br>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。</p><p>（图片来源：<a href="https://blog.csdn.net/login_sonata/article/details/76598675）" target="_blank" rel="noopener">https://blog.csdn.net/login_sonata/article/details/76598675）</a></p><p><img src="https://img-blog.csdn.net/20170803204952538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbG9naW5fc29uYXRh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>为了方便理解，附HashSet存储原理图（即HashMap底层）（图片来源网络，具体不详）</p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz5focw9yyj30sp0qw0xg.jpg" alt="hashmap底层"></p><h5 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a><strong>LinkedHashSet类</strong></h5><p>LinkedHashSet类也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序。与HashSet相比，特点：</p><ol><li>对集合迭代时，按增加顺序返回元素。</li><li>性能略低于HashSet，因为需要维护元素的插入顺序。但迭代访问元素时会有好性能，因为它采用链表维护内部顺序。</li></ol><h4 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a><strong>Map集合</strong></h4><p>Map集合提供的是key到value的映射，Map中不能包含相同的key，每个key只能映射一个value，key决定了存储对象在映射中的存储位置，但不是key对象本身决定的，而是由一种“散列技术”进行处理，产生一个散列码的整数值，散列码通常用作一个偏移量，该偏移量对应分配给映射的内存区域的起始位置，从而确定储存对象在映射中的储存位置，Map集合包括Map接口以及接口的所有实现类。</p><p>Map常用子类：</p><ul><li><p>HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需 要重写键的hashCode()方法、equals()方法。</p></li><li><p>LinkedHashMap：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链 表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的 hashCode()方法、equals()方法。</p></li></ul><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><strong>Map接口</strong></h5><p>Map接口常用方法：</p><ul><li>public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。</li><li>public V remove(Object key) : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li>public V get(Object key) 根据指定的键，在Map集合中获取对应的值。</li><li>public Set<k>keySet() : 获取Map集合中所有的键，存储到Set集合中。</k></li><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 map对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//String remove(String key)</span></span><br><span class="line">        System.out.println(map.remove(<span class="string">"s2"</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        System.out.println(map.get(<span class="string">"s1"</span>));</span><br><span class="line">        System.out.println(map.get(<span class="string">"s3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a><strong>Map集合遍历键找值方式</strong></h5><p>键找值方式：即通过元素中的键，获取键所对应的值<br>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示: keyset()</li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示: get(K key)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">//获取所有的键 获取键集</span></span><br><span class="line">            Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        <span class="comment">//key 就是键</span></span><br><span class="line">        <span class="comment">//获取对应值</span></span><br><span class="line">        String value = map.get(key);</span><br><span class="line">        System.out.println(key+<span class="string">"的value是："</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a><strong>Entry键值对对象</strong></h5><p>Map 中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map 中是一一对应关系，这一对对象又称做Map 中的一个Entry(项) 。Entry 将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map 集合时，就可以从每一个键值对（ Entry ）对象中获取对应的键与对应的值。</p><p>既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li>public K getKey() ：获取Entry对象中的键。</li><li>public V getValue() ：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h5 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a><strong>Map集合遍历键值对方式</strong></h5><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>分析步骤：</p><ol><li>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示: entrySet() 。</li><li>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li>通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示: getkey() getValue()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        map.put(<span class="string">"s1"</span>, <span class="string">"str1"</span>);</span><br><span class="line">        map.put(<span class="string">"s2"</span>, <span class="string">"str2"</span>);</span><br><span class="line">        map.put(<span class="string">"s3"</span>, <span class="string">"str3"</span>);</span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象 entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        System.out.println(key+<span class="string">"的value是:"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a><strong>LinkedHashMap</strong></h4><p>HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，要保证有序，还要速度快就要使用HashMap下面的一个子类LinkedHashMap，是链表和哈希表组合的一个数据存储结构。完美解决以上问题</p><h4><a href="#" class="headerlink"></a></h4><h4 id="-1"><a href="#-1" class="headerlink"></a></h4><h4 id="-2"><a href="#-2" class="headerlink"></a></h4><h4 id="-3"><a href="#-3" class="headerlink"></a></h4><h4 id="-4"><a href="#-4" class="headerlink"></a></h4><h4 id="-5"><a href="#-5" class="headerlink"></a></h4><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> List </tag>
            
            <tag> Map </tag>
            
            <tag> Set </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象之三大特性</title>
      <link href="/2017/03/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2017/03/29/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>Java 语言重要思想即面向对象，一切皆对象，且具有三大特征：继承、封装 、多态。面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。可以将复杂的业务逻辑简单化，增强代码的复用性，亦而比较符合人们的思考习惯。</p><a id="more"></a><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a><strong>类和对象</strong></h3><p>（1）类：类是对某一类事物的抽象描述，是对象的模板，确定对象将会拥有的特征(属性)和行为(方法)。</p><p>​ 特点：类是具有相同属性和方法的一组对象的集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line"><span class="comment">//可编写0至n个属性</span></span><br><span class="line">数据类型 变量名<span class="number">1</span>;</span><br><span class="line">数据类型 变量名<span class="number">2</span>;</span><br><span class="line"><span class="comment">//可编写0至n个方法</span></span><br><span class="line">修饰符 返回值类型 方法名(参数)&#123;</span><br><span class="line">执行语句;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）对象：用于描述现实中的个体,它是类的实例。</p><p>创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名()</span><br><span class="line"></span><br><span class="line">对象.属性   /   对象.方法名()</span><br></pre></td></tr></table></figure><p>（3）成员变量与局部变量</p><p>成员变量：在类中定义，用来描述对象将要有什么。（作用域在整个类内部都是可见的）</p><p>局部变量：在类的方法中定义，在方法中临时保存数据。（作用域仅限于定义它的方法）</p><p>区别：</p><ul><li>作用域不同</li><li>两类变量同名时，局部变量的优先级更高</li><li>初始值不同：Java会给成员变量一个初始值，不会给局部变量赋予初始值</li></ul><p>（4）构造方法：定义在Java中的一个用来初始化对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义格式</span></span><br><span class="line">修饰符 类名 (参数列表) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用new+构造方法 创建一个新的对象。</li><li>名称与类名相同且没有返回值。</li><li>当没有指定构造方法时，系统会自动添加无参的构造方法。</li><li>当有指定构造方法时，无论是有参、无参的构造方法，都不会自动添加无参的构造方法。</li><li>构造方法可重载：方法名相同，但参数不同，调用时会自动根据不同的参数选择相应的方法。</li><li>构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值（在构造函数中增加判断）。</li></ul><p>（5）static静态变量（也称类成员）</p><ul><li>它属于整个类所有，而不是某个对象所有，被类的所有对象所共享。</li><li>静态成员可使用类名直接访问，也可以使用对象名进行访问。</li><li>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收。</li></ul><p>（6）static静态方法（也称类方法）</p><ul><li>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。</li><li>如果系统在静态方法中调用非静态变量，可通过创建类的对象，然后通过对象来访问非静态变量。</li><li>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量。</li><li>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。</li></ul><p>（7）初始化块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.普通初始化块</span></span><br><span class="line">&#123;</span><br><span class="line">xxx = xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">xxx = xxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***执行顺序：静态初始化块最先被执行--&gt;普通初始化块--&gt;构造方法</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面向对象共有三个特征:封装,继承,多态</span></span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><p>（1）概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法类实现对隐藏信息的操作和访问。</p><p>（2）好处：只能同规定的方法访问数据，隐藏类的实现细节，方便修改和实现，提高了代码的复用性以及安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如: Arrays.sort(arr);//完成排序 sort方法封装了排序的算法</span></span><br></pre></td></tr></table></figure><p>（3）实现步骤</p><ol><li>修改属性的可见性：设为private</li><li>创建getter/setter方法：用于属性的读写</li><li>在getter/setter方法中加入属性控制语句：对属性值的合法性进行判断</li></ol><p>（4）Java中的包</p><ul><li>作用：管理Java文件，解决同名文件的冲突</li><li>必须放在Java源程序的第一行，包名间用”.”号隔开</li><li>包的使用：可以通过import关键字在某个文件中使用其它文件中的类，Java包的命名是全小写字母</li></ul><p>（5）Java中的访问修饰符：可以修饰属性和方法的访问范围</p><ul><li>private：只能在本类中访问和使用。</li><li>default(默认)：能在本类和同包中访问和使用。</li><li>protected：能在本类、同包、子类中使用。</li><li>public：在本类、同包、子类、其它类中使用。</li></ul><p>（6）Java中this关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表当前对象,即本类对象的引用</span></span><br><span class="line"><span class="comment">//this是在方法中使用的,哪个对象调用了该方法,this就代表调用该方法的对象引用</span></span><br><span class="line"><span class="comment">//this什么时候存在的?当创建对象的时候,this存在的</span></span><br><span class="line"><span class="comment">//this的作用:用来区别同名的成员变量与局部变量(this.成员变量)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.属性：操作当前对象的属性</span><br><span class="line"><span class="keyword">this</span>.方法：调用当前对象的方法</span><br></pre></td></tr></table></figure><p>（7）内部类：定义在另外一个类里面的类。</p><p>作用：</p><ul><li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据。</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时候使用内部类更方便。</li></ul><p>分类：成员内部类，静态内部类，方法内部类，匿名内部类。</p><p>（8）成员内部类(也称普通内部类)</p><ul><li>内部类定义在外部类内部，相当于外部类的一个成员变量的位置，内部类可以使用任意访问控制符。</li><li>内部类中的方法可以直接访问外部类中的数据，而不受访问控制符的影响。</li><li>定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去new一个内部类对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即： 内部类 对象名 = 外部类对象.new 内部类()</span></span><br></pre></td></tr></table></figure><ul><li>外部类不能直接使用内部类的成员和方法，创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</li><li>如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可使用：外部类.this.对象名</li></ul><p>（9）静态内部类(static修饰的内部类)</p><ul><li>静态内部类不能直接访问外部类的非静态成员，但可通过”new 外部类().成员”的方式访问</li><li>如果外部类的静态成员与内部类的成员名称相同，可通过”类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过”成员名” 直接调用。</li><li>创建静态内部类的对象时，不需要外部类的对象，可以直接创建：内部类 对象名 = new 内部类();</li></ul><p>（10）方法内部类</p><p>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</p><p>注意：由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制修饰符和static修饰符。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>概念：</p><p>​ 指在一个现有类的基础上去构建一个新的类,构建出来的新类被称作子类,现有类被称作父类,子类会自动拥有父类所有的非私有属性和方法。</p><p>继承的优点：</p><ul><li>提高代码复用性</li><li>父类的属性方法可以用于子类</li><li>利于程序的设计，使设计应用程序变得简单</li><li>易于扩展</li></ul><p>继承的缺点：</p><ul><li>继承是侵入性的，只要继承，就必须拥有父类的所有属性和方法</li><li>降低了代码的灵活性</li><li>增强了耦合性</li><li>打破了封装性</li></ul><p>（1）继承时类与类的一种关系，是一种”is a”的关系</p><p>（2）Java中的继承时单继承，只有一个父类</p><p>（3）class 子类 extends 父类</p><p>（4）方法的重写</p><ul><li>子类可重写从父类继承的方法，当调用方法时会优先调用子类的方法。</li><li>返回值类型、方法名、参数类型及个数 都要与父类继承的方法相同，才叫方法的重写。</li></ul><p>（5）继承的初始化顺序</p><ul><li>初始化父类再初始化子类</li><li>属性的初始化在构造方法之前执行。</li><li>父类的属性初始化–&gt;父类的构造函数–&gt;子类的属性初始化–&gt;子类的构造函数</li></ul><p>（6）final</p><p>可修饰类、方法、属性和变量</p><ul><li>final修饰类，则该类不允许被继承</li><li>final修饰方法，则该方法不允许被覆盖(重写)</li><li>final修饰属性，则该类的属性不会进行隐式初始化（类的初始化属性必须有值）或在构造方法中赋值（只能任选其一）</li><li>final修饰变量，则该变量的值只能赋一次值，即变为常量</li></ul><p>（7）super关键字</p><p>在对象的内部使用，可以代表父类，指的是父类的存储空间(理解为父类的引用)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用父类的成员变量:</span></span><br><span class="line"><span class="keyword">super</span>.成员变量;</span><br><span class="line"><span class="comment">//调用父类的构造方法:</span></span><br><span class="line"><span class="keyword">super</span>(参数);</span><br><span class="line"><span class="comment">//调用方法的成员方法:</span></span><br><span class="line"><span class="keyword">super</span>.成员方法();</span><br><span class="line">**在创建子类对象时,父类的构造方法会先执行,因为子类中所有构造方法的第一行有默认的隐式<span class="keyword">super</span>();语句。</span><br><span class="line"><span class="comment">//调用本类中的构造方法</span></span><br><span class="line"><span class="keyword">this</span>(实参列表);</span><br><span class="line"><span class="comment">//调用父类中的空参数构造方法</span></span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="comment">//调用父类中的有参数构造方法</span></span><br><span class="line"><span class="keyword">super</span>(实参列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当在方法中出现了局部变量和成员变量同名的时候,可以在成员变量名前面加上this.来区别成员变量和局部变量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子父类中出现了同名成员变量时,在子类中若要访问父类中的成员变量,必须使用关键字super来完成。super用来表示当前对象中包含的父类对象空间的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在子类中,访问父类中的成员变量格式:</span></span><br><span class="line"><span class="keyword">super</span>.父类中的成员变量</span><br><span class="line">System.out.println(“Fu num=”+<span class="keyword">super</span>.num);</span><br><span class="line"><span class="comment">//访问子类中的num2</span></span><br><span class="line">System.out.println(“Zi num2=”+<span class="keyword">this</span>.num);</span><br><span class="line"><span class="comment">//在子类中,访问父类中的成员方法格式:</span></span><br><span class="line"><span class="keyword">super</span>.父类中的成员方法();</span><br></pre></td></tr></table></figure><p>（8）Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另一个类，那么这个类默认继承Object类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><ul><li><p>继承是多态实现的基础，理解为同一种物质的多种形态。</p></li><li><p>使用前提：有继承或者实现关系</p></li><li><p>好处：提高了程序的扩展性</p></li><li><p>弊端：不能访问子类特有功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg：</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(“重写父类抽象方法”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的多态使用</span></span><br><span class="line">Fu fu= <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li></ul><p>（1）引用多态：父类的引用可以指向本类的对象/父类的引用可以指向子类的对象。</p><p>（2）方法多态：创建本类对象时，调用的方法为本类方法/创建子类对象时，调用的方法为子类重写的方法或继承的方法。</p><p>（3）引用类型转换</p><ul><li>向上类型转换：隐式/自动类型转换，小类型到大类型的转换。（无风险）</li><li>向下类型转换：强制类型转换，是大类型到小类型。（有风险）</li></ul><p>（4）抽象类</p><p>应用场景：在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。</p><ul><li>从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。</li><li>限制规定子类必须实现某些方法，但不关注实现细节。</li><li>abstract定义抽象类</li><li>abstract定义抽象方法，只有声明，不需要实现</li><li>包含抽象方法的类是抽象类</li><li>抽象类中可以包含普通的方法，也可以没有抽象方法</li><li>抽象类不能直接创建，可以定义引用变量</li></ul><p>（5）接口</p><ul><li>接口可以理解为一种特殊的类，由全局常量和公共的抽象方法所组成。</li><li>类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供某些方法。</li><li>接口定义的基本语法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口1, 父接口2]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="number">1</span>-n常量定义...</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>-n抽象方法的定义....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的多态</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(“重写接口抽象方法”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的多态使用</span></span><br><span class="line">Fu fu = <span class="keyword">new</span> Zi()</span><br></pre></td></tr></table></figure><ul><li>Java中一个类只能有一个父类，不够灵活，可通过实现多个接口增加灵活性。</li><li>接口中属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上。</li><li>接口中方法只能是抽象方法，系统会自动添加public abstract</li></ul><p>抽象类和接口的区别（表格来源：<a href="http://www.importnew.com/12399.html）" target="_blank" rel="noopener">http://www.importnew.com/12399.html）</a></p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz4v0go92sj30lo0kdtb2.jpg" alt="抽象类和接口的区别"></p><p>（6）UML</p><p>概念：统一建模语言或标准建模语言，支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持。</p><p>常用的UML图:</p><p>用例图：能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求信息。</p><p>序列图：用于安置交互发生的一系列顺序，显示对象之间的这些交互。</p><p>类图：UML类图、业务逻辑和所有支持结构被用于定义全部的代码结构。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 封装 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Arrays.asList()抛出UnsupportOperationException异常</title>
      <link href="/2017/03/20/%E6%B5%85%E8%B0%88Arrays.asList()%E6%8A%9B%E5%87%BAUnsupportOperationException%E5%BC%82%E5%B8%B8/"/>
      <url>/2017/03/20/%E6%B5%85%E8%B0%88Arrays.asList()%E6%8A%9B%E5%87%BAUnsupportOperationException%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>初学数组常见的坑之一，执行Arrays.asList()时抛出UnsupportOperationException异常</p><a id="more"></a><p>前言：</p><p>写数组那篇文章不禁想起了以前做呆莫的时候遇到一个小坑，是什么呢？就是万恶的基础知识不是很牢（cai）固（ji）！操作数组与集合之间相互转化时报了一个 UnsupportOperationException 异常。</p><p>现场极简还原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String array[] = &#123;<span class="string">"test data-string"</span>&#125;;</span><br><span class="line">List array2list = Arrays.asList(array);</span><br><span class="line">array2list.add(<span class="string">"test data-list"</span>);</span><br><span class="line"><span class="comment">//执行以上代码就会抛出 UnsupportOperationException 异常。异常是第三行导致的。</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">148</span>)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:<span class="number">108</span>)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>才开始学习的时候，头发都掉了整整一根，这是尼玛何等卧槽。。。但还是没有想出来为啥子，最后还是机智的琢（bai）磨（du）出来了，先看AIP:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span></span><br><span class="line"><span class="function">返回一个受指定数组支持的固定大小的列表。（对返回列表的更改会“直接写”到数组。）此方法同 Collection.<span class="title">toArray</span><span class="params">()</span> 一起，充当了基于数组的 API 与基于 collection 的 API 之间的桥梁。返回的列表是可序列化的，并且实现了 RandomAccess。</span></span><br><span class="line"><span class="function">此方法还提供了一个创建固定长度的列表的便捷方法，该列表被初始化为包含多个元素：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">     List&lt;String&gt; stooges </span>= Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line"> </span><br><span class="line">参数：</span><br><span class="line">a - 支持列表的数组。</span><br><span class="line">返回：</span><br><span class="line">指定数组的列表视图。</span><br></pre></td></tr></table></figure><p>在操作数组执行Arrays.asList()调用add()、remove()…时出现 java.lang.UnsupportedOperationException异常。</p><p>Arrays.asList() 返回定长的 List，不支持 add 和 remove 操作。</p><p>Arrays.asList() 返回java.util.Arrays$ArrayList， 而不是ArrayList。返回的对象是一个Arrays内部类,并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><p>Arrays$ArrayList和ArrayList都是继承AbstractList，remove，add等 method在AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。</p><p>ArrayList override这些method来对list进行操作，但是Arrays$ArrayList没有override remove()，add()等，所以throw UnsupportedOperationException。</p><p>那有解决办法不？这不废话么！</p><p>一解：老老实实的遍历数组，将数组的每个元素添加到集合中。不足于会降低程序执行效率。</p><p>二解：使用了Arrays.asList()方法后将得到的集合再进行强转成集合类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String [] array = &#123;<span class="string">"test data-string"</span>&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; array2list = Arrays.asList(array);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; arrList = <span class="keyword">new</span> ArrayList&lt;String&gt;(array2list);</span><br><span class="line">arrList.add(<span class="string">"hello"</span>);</span><br><span class="line">        </span><br><span class="line">System.out.println(arrList);<span class="comment">//[test data-string, hello]</span></span><br></pre></td></tr></table></figure><p>还有其他解决方案，在此不再赘述。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array/数组</title>
      <link href="/2017/03/20/Array/"/>
      <url>/2017/03/20/Array/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>所谓数组，是有序的元素序列。若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。这些无序排列的同类数据元素的集合称为数组。</p><a id="more"></a><p>（在此不考虑三维数组，重点理解掌握数组在内存中的地址引用）<br>1.数组的概念：<br>​ 数组就是存储数据长度固定的容器，且多个数据的数据类型一致。<br>1.1各个维度的数组模型<br>（图片来源网络，具体出处未知）</p><p><img src="http://wx4.sinaimg.cn/mw690/0077hIeDgy1fz17tpi61oj30ji0l3whv.jpg" alt="数组地址内存图"></p><p><img src="http://wx4.sinaimg.cn/mw690/0077hIeDly1fz17yg5a4rj30jj0c4mxz.jpg" alt="java内存图"></p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a><strong>一维数组</strong></h3><p>数组定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 </span></span><br><span class="line"><span class="comment">[] : 表示数组。 </span></span><br><span class="line"><span class="comment">数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 </span></span><br><span class="line"><span class="comment">new：关键字，创建数组使用的关键字。</span></span><br><span class="line"><span class="comment">数组存储的数据类型： 创建的数组容器可以存储什么数据类型。 </span></span><br><span class="line"><span class="comment">[长度]：数组的长度，表示数组容器中可以存储多少个元素。 </span></span><br><span class="line"><span class="comment">注意：数组有定长特性，长度一旦指定，不可更改</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];</span></span><br><span class="line"><span class="comment">//exp：</span></span><br><span class="line"><span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;</span></span><br><span class="line"><span class="comment">//exp：</span></span><br><span class="line"><span class="keyword">int</span> [] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三:</span></span><br><span class="line"><span class="comment">//数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;</span></span><br><span class="line"><span class="comment">//exp：</span></span><br><span class="line"><span class="keyword">int</span> [] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h3><p>数组定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法一：数据类型[][] 数组名 = new int[二维数组的长度][一维数组的长度];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法二：数据类型[][] 数组名 = new int[二维数组的长度][];(此种方式定义的一维数组需要另外分配长度，其长度可以不相同)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//语法三：数据类型[][] 数组名 = new int[][]&#123;&#123;初始化数据&#125;,&#123;初始化数据&#125;&#125;;(每一对花括号是一个一维数组，使用逗号分割。此种方式定义的一维数组的长度可以不相同)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二位数组的创建方式一</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_08</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式二</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_09</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];    <span class="comment">//给第一个一维数组分配大小</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];    <span class="comment">//给第二个一维数组分配大小</span></span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式三</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_10</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h3><p>每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。</p><p>3.1通过索引访问一位数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组名[索引值]</span></span><br><span class="line">array[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>3.2通过索引访问二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组名[二维数组的索引][一维数组的索引]</span></span><br><span class="line"><span class="comment">//访问数组中的元素</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_11</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">10</span>,<span class="number">20</span>&#125;,&#123;<span class="number">50</span>,<span class="number">66</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//输出第二个一维数组中的第一个元素</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组长度属性"><a href="#数组长度属性" class="headerlink" title="数组长度属性"></a><strong>数组长度属性</strong></h3><p>​ 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的 长度，语句为： 数组名.length ，属性length的执行结果是数组的长度，int类型结果。由次可以推断出，数 组的最大索引值为 数组名.length-1 。</p><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a><strong>数组遍历</strong></h3><p>5.1一维数组的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环遍历数组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_05</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while循环遍历数组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_06</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; arr.length)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.2二维数组的遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二位数组的创建方式一</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_08</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式二</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_09</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];    <span class="comment">//给第一个一维数组分配大小</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];    <span class="comment">//给第二个一维数组分配大小</span></span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二位数组的创建方式三</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_10</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//输出二位数组的长度</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    <span class="comment">//输出第一个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>].length);</span><br><span class="line">    <span class="comment">//输出第二个一维数组的长度</span></span><br><span class="line">    System.out.println(arr[<span class="number">1</span>].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用操作（方法）"><a href="#常用操作（方法）" class="headerlink" title="常用操作（方法）"></a><strong>常用操作（方法）</strong></h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="http://www.runoob.com/jsref/jsref-concat-array.html" target="_blank" rel="noopener">concat()</a></td><td>连接两个或更多的数组，并返回结果。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-copywithin.html" target="_blank" rel="noopener">copyWithin()</a></td><td>从数组的指定位置拷贝元素到数组的另一个指定位置中。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-every.html" target="_blank" rel="noopener">every()</a></td><td>检测数值元素的每个元素是否都符合条件。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-fill.html" target="_blank" rel="noopener">fill()</a></td><td>使用一个固定值来填充数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-filter.html" target="_blank" rel="noopener">filter()</a></td><td>检测数值元素，并返回符合条件所有元素的数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-find.html" target="_blank" rel="noopener">find()</a></td><td>返回符合传入测试（函数）条件的数组元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-findindex.html" target="_blank" rel="noopener">findIndex()</a></td><td>返回符合传入测试（函数）条件的数组元素索引。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-foreach.html" target="_blank" rel="noopener">forEach()</a></td><td>数组每个元素都执行一次回调函数。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-indexof-array.html" target="_blank" rel="noopener">indexOf()</a></td><td>搜索数组中的元素，并返回它所在的位置。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-join.html" target="_blank" rel="noopener">join()</a></td><td>把数组的所有元素放入一个字符串。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-lastindexof-array.html" target="_blank" rel="noopener">lastIndexOf()</a></td><td>返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-map.html" target="_blank" rel="noopener">map()</a></td><td>通过指定函数处理数组的每个元素，并返回处理后的数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-pop.html" target="_blank" rel="noopener">pop()</a></td><td>删除数组的最后一个元素并返回删除的元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-push.html" target="_blank" rel="noopener">push()</a></td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-reduce.html" target="_blank" rel="noopener">reduce()</a></td><td>将数组元素计算为一个值（从左到右）。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-reduceright.html" target="_blank" rel="noopener">reduceRight()</a></td><td>将数组元素计算为一个值（从右到左）。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-reverse.html" target="_blank" rel="noopener">reverse()</a></td><td>反转数组的元素顺序。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-shift.html" target="_blank" rel="noopener">shift()</a></td><td>删除并返回数组的第一个元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-slice-array.html" target="_blank" rel="noopener">slice()</a></td><td>选取数组的的一部分，并返回一个新数组。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-some.html" target="_blank" rel="noopener">some()</a></td><td>检测数组元素中是否有元素符合指定条件。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-sort.html" target="_blank" rel="noopener">sort()</a></td><td>对数组的元素进行排序。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-splice.html" target="_blank" rel="noopener">splice()</a></td><td>从数组中添加或删除元素。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-tostring-array.html" target="_blank" rel="noopener">toString()</a></td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-unshift.html" target="_blank" rel="noopener">unshift()</a></td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td><a href="http://www.runoob.com/jsref/jsref-valueof-array.html" target="_blank" rel="noopener">valueOf()</a></td><td>返回数组对象的原始值。</td></tr></tbody></table><p>6.1Arrays 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Object[] a, Object key)</span></span></span><br><span class="line"><span class="function"><span class="comment">//用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">long</span>[] a, <span class="keyword">long</span>[] a2)</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。（也可用后续的冒泡排序）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Arrays.asList</span></span><br><span class="line"><span class="function"><span class="comment">//使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportOperationException异常</span></span></span><br><span class="line"><span class="function"><span class="comment">//说明：asList的返回对象是一个Arrays内部类,并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">toString</span></span><br><span class="line"><span class="function"><span class="comment">//将数组转成字符串</span></span></span><br></pre></td></tr></table></figure><p>6.2ArrayUtils类（更多具体方法查阅网络）</p><p>6.2.1反转数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">ArrayUtils.reverse(intArray);</span><br><span class="line"><span class="comment">//[5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>6.2.2移除数组中的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] removed = ArrayUtils.removeElement(intArray, <span class="number">3</span>);<span class="comment">//create a new array</span></span><br></pre></td></tr></table></figure><p>6.2.3合并数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] intArray2 = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">// Apache Commons Lang library</span></span><br><span class="line"><span class="keyword">int</span>[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);</span><br></pre></td></tr></table></figure><p>6.3判断数组是否包含某一个值（将数组转成集合，再使用集合的contains()方法进行判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span> &#125;;</span><br><span class="line"><span class="keyword">boolean</span> b = Arrays.asList(stringArray).contains(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以用Arrays.toString(str).contains进行判断，先将数组转成字符串，再用字符串的contains()方法进行判断</span></span><br></pre></td></tr></table></figure><p>6.4求数组中最大最小值</p><p>假设下标为0的元素是最大值，遍历数组，依次跟max进行比较，如果有元素比这个max还大，则把这个值赋给max。最小值同样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">23</span>,<span class="number">45</span>,<span class="number">234</span>,<span class="number">576</span>,<span class="number">34</span>,<span class="number">87</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]&gt;max)&#123;</span><br><span class="line">        max=arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(arr[i]&lt;min)&#123;</span><br><span class="line">        min=arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6.5对数组进行排序（冒泡排序）（与Arrays.sort()方法排序效果一样）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr=&#123;<span class="number">10</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//外层循环控制比较轮数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      <span class="comment">//内层循环控制每轮比较次数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">          arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数组-深-浅-拷贝（克隆）"><a href="#数组-深-浅-拷贝（克隆）" class="headerlink" title="数组 深/浅 拷贝（克隆）"></a><strong>数组 深/浅 拷贝（克隆）</strong></h3><p>将arr拷贝到brr<br>浅拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[]arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">5</span>&#125;; </span><br><span class="line">brr=arr; </span><br><span class="line">brr[<span class="number">2</span>]=<span class="number">20</span>;<span class="comment">//new arr[2]也等与20</span></span><br></pre></td></tr></table></figure><p>这种拷贝只是将arr所表示的数组在栈中的地址代码拷贝到了brr中，brr所引用的数组与arr其实就是同一个。因此叫它浅拷贝。</p><p>深拷贝：<br>1.利用for循环结构,逐个将数组arr中的值赋给已经进行了空间开辟的数组brr</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[]arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">int</span>[]brr=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=o;i&lt;arr.length;i++)&#123; </span><br><span class="line">    brr[i]=arr[i]; </span><br><span class="line">     &#125; </span><br><span class="line">brr[<span class="number">2</span>]=<span class="number">30</span>;<span class="comment">//此时arr[2]=5</span></span><br></pre></td></tr></table></figure><p>2.利用Arrays类中的copyOf方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arr中所有的元素均被拷贝到brr中，第二个参数便是新数组的长度 </span></span><br><span class="line"><span class="keyword">int</span>[]brr=Arrays.copyOf(arr,arr.length); </span><br><span class="line"><span class="comment">//该方法也可用来增加数组的长度 </span></span><br><span class="line">brr=Arrays.copyOf(arr,<span class="number">2</span>*arr.length);</span><br></pre></td></tr></table></figure><p>3.用System类的arraycopy方法进行拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System.arraycopy(from,fromIndex,to,toIndex,count);</span></span><br><span class="line"><span class="comment">//拷贝从arr的0索引开始到brr的0索引开始，一共拷贝arr.length个元素</span></span><br><span class="line">System.arraycopy(arr,<span class="number">0</span>,brr,<span class="number">0</span>,arr.length);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Array </tag>
            
            <tag> 数组 </tag>
            
            <tag> 一维数组 </tag>
            
            <tag> 二维数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String/字符串</title>
      <link href="/2017/03/19/String/"/>
      <url>/2017/03/19/String/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。<br>类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻 译为大写或小写的所有字符的字符串的副本。</p><p>特点：字符串的值在创建后不能被更改（字符串不变）。</p><a id="more"></a><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h3><ul><li>public String()：初始化新创建的 String对象，以使其表示空字符序列。</li><li>public String(char[] value)：通过当前参数中的字符数组来构造新的String。</li><li>public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新String。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有三个构造方法</span></span><br><span class="line"><span class="comment">//无参构造 </span></span><br><span class="line">String str = <span class="keyword">new</span> String（）； </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字符数组构造 </span></span><br><span class="line"><span class="keyword">char</span> chars[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;      </span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字节数组构造 </span></span><br><span class="line"><span class="keyword">byte</span> bytes[] = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;      </span><br><span class="line">String str3 = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure><h3 id="常用方法（操作）"><a href="#常用方法（操作）" class="headerlink" title="常用方法（操作）"></a><strong>常用方法（操作）</strong></h3><h4 id="判断"><a href="#判断" class="headerlink" title="判断"></a><strong>判断</strong></h4><ul><li>public boolean equals (Object anObject)：将此字符串与指定对象进行比较。</li><li>public boolean equalsIgnoreCase (String anotherString)：将此字符串与指定对象进行比较，忽略大小</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo01</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">    <span class="comment">// 创建字符串对象     </span></span><br><span class="line">    String s1 = <span class="string">"hello"</span>;     </span><br><span class="line">    String s2 = <span class="string">"hello"</span>;     </span><br><span class="line">    String s3 = <span class="string">"HELLO"</span>;     </span><br><span class="line">    <span class="comment">//boolean equals(Object obj):比较字符串的内容是否相同</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s3)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    <span class="comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s2)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equalsIgnoreCase(s3)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br></pre></td></tr></table></figure><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a><strong>获取</strong></h4><ul><li>public int length () ：返回此字符串的长度。</li><li>public String concat (String str) ：将指定的字符串连接到该字符串的末尾。</li><li>public char charAt (int index) ：返回指定索引处的 char值。</li><li>public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。</li><li>public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</li><li>public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"helloworld"</span>;</span><br><span class="line">        <span class="comment">// int length():获取字符串的长度，其实也就是字符个数</span></span><br><span class="line">        System.out.println(s.length());</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span></span><br><span class="line">        String s = <span class="string">"helloworld"</span>;</span><br><span class="line">        String s2 = s.concat(<span class="string">"**hello world"</span>);</span><br><span class="line">        System.out.println(s2);<span class="comment">// helloworld**hello wolrd</span></span><br><span class="line">        <span class="comment">// char charAt(int index):获取指定索引处的字符</span></span><br><span class="line">        System.out.println(s.charAt(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span></span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"l"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"owo"</span>));</span><br><span class="line">        System.out.println(s.indexOf(<span class="string">"ak"</span>));</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// String substring(int start):从start开始截取字符串到字符串结尾</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>));</span><br><span class="line">        System.out.println(s.substring(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end。</span></span><br><span class="line">        System.out.println(s.substring(<span class="number">0</span>, s.length()));</span><br><span class="line">        System.out.println(s.substring(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a><strong>转换</strong></h4><ul><li>public char[] toCharArray () ：将此字符串转换为新的字符数组。</li><li>public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li><li>public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"abcde"</span>;</span><br><span class="line">        <span class="comment">// char[] toCharArray():把字符串转换为字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chs.length; x++) &#123;</span><br><span class="line">        System.out.println(chs[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// byte[] getBytes ():把字符串转换为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; bytes.length; x++) &#123;</span><br><span class="line">        System.out.println(bytes[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">        <span class="comment">// 替换字母swu为大写SWU</span></span><br><span class="line">        String str = <span class="string">"swuswu"</span>;</span><br><span class="line">        String replace = str.replace(<span class="string">"swu"</span>, <span class="string">"SWU"</span>);</span><br><span class="line">        System.out.println(replace); <span class="comment">// SWUSWU</span></span><br><span class="line">        System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分割"><a href="#分割" class="headerlink" title="分割"></a><strong>分割</strong></h4><ul><li>public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String_Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建字符串对象</span></span><br><span class="line">        String s = <span class="string">"aa|bb|cc"</span>;</span><br><span class="line">        String[] strArray = s.split(<span class="string">"|"</span>); <span class="comment">// ["aa","bb","cc"]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; strArray.length; x++) &#123;</span><br><span class="line">        System.out.println(strArray[x]); <span class="comment">// aa bb cc</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a><strong>连接</strong></h4><p>使用String类提供的concat() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string1.concat(string2);</span><br></pre></td></tr></table></figure><p>String类支持的方法（附菜鸟教程的String表格 :<a href="http://www.runoob.com/java/java-string.html）" target="_blank" rel="noopener">http://www.runoob.com/java/java-string.html）</a></p><p><strong><em>具体使用参照以上用法规则</em></strong></p><table><thead><tr><th>SN(序号)</th><th>方法描述</th></tr></thead><tbody><tr><td>1</td><td><a href="http://www.runoob.com/java/java-string-charat.html" target="_blank" rel="noopener">char charAt(int index)</a>返回指定索引处的 char 值。</td></tr><tr><td>2</td><td><a href="http://www.runoob.com/java/java-string-compareto.html" target="_blank" rel="noopener">int compareTo(Object o)</a>把这个字符串和另一个对象比较。</td></tr><tr><td>3</td><td><a href="http://www.runoob.com/java/java-string-compareto.html" target="_blank" rel="noopener">int compareTo(String anotherString)</a>按字典顺序比较两个字符串。</td></tr><tr><td>4</td><td><a href="http://www.runoob.com/java/java-string-comparetoignorecase.html" target="_blank" rel="noopener">int compareToIgnoreCase(String str)</a>按字典顺序比较两个字符串，不考虑大小写。</td></tr><tr><td>5</td><td><a href="http://www.runoob.com/java/java-string-concat.html" target="_blank" rel="noopener">String concat(String str)</a>将指定字符串连接到此字符串的结尾。</td></tr><tr><td>6</td><td><a href="http://www.runoob.com/java/java-string-contentequals.html" target="_blank" rel="noopener">boolean contentEquals(StringBuffer sb)</a>当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td></tr><tr><td>7</td><td><a href="http://www.runoob.com/java/java-string-copyvalueof.html" target="_blank" rel="noopener">static String copyValueOf(char[] data)</a>返回指定数组中表示该字符序列的 String。</td></tr><tr><td>8</td><td><a href="http://www.runoob.com/java/java-string-copyvalueof.html" target="_blank" rel="noopener">static String copyValueOf(char[] data, int offset, int count)</a>返回指定数组中表示该字符序列的 String。</td></tr><tr><td>9</td><td><a href="http://www.runoob.com/java/java-string-endswith.html" target="_blank" rel="noopener">boolean endsWith(String suffix)</a>测试此字符串是否以指定的后缀结束。</td></tr><tr><td>10</td><td><a href="http://www.runoob.com/java/java-string-equals.html" target="_blank" rel="noopener">boolean equals(Object anObject)</a>将此字符串与指定的对象比较。</td></tr><tr><td>11</td><td><a href="http://www.runoob.com/java/java-string-equalsignorecase.html" target="_blank" rel="noopener">boolean equalsIgnoreCase(String anotherString)</a>将此 String 与另一个 String 比较，不考虑大小写。</td></tr><tr><td>12</td><td><a href="http://www.runoob.com/java/java-string-getbytes.html" target="_blank" rel="noopener">byte[] getBytes()</a> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td>13</td><td><a href="http://www.runoob.com/java/java-string-getbytes.html" target="_blank" rel="noopener">byte[] getBytes(String charsetName)</a>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td></tr><tr><td>14</td><td><a href="http://www.runoob.com/java/java-string-getchars.html" target="_blank" rel="noopener">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</a>将字符从此字符串复制到目标字符数组。</td></tr><tr><td>15</td><td><a href="http://www.runoob.com/java/java-string-hashcode.html" target="_blank" rel="noopener">int hashCode()</a>返回此字符串的哈希码。</td></tr><tr><td>16</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(int ch)</a>返回指定字符在此字符串中第一次出现处的索引。</td></tr><tr><td>17</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(int ch, int fromIndex)</a>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td></tr><tr><td>18</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(String str)</a> 返回指定子字符串在此字符串中第一次出现处的索引。</td></tr><tr><td>19</td><td><a href="http://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(String str, int fromIndex)</a>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td></tr><tr><td>20</td><td><a href="http://www.runoob.com/java/java-string-intern.html" target="_blank" rel="noopener">String intern()</a> 返回字符串对象的规范化表示形式。</td></tr><tr><td>21</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(int ch)</a> 返回指定字符在此字符串中最后一次出现处的索引。</td></tr><tr><td>22</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(int ch, int fromIndex)</a>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td></tr><tr><td>23</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(String str)</a>返回指定子字符串在此字符串中最右边出现处的索引。</td></tr><tr><td>24</td><td><a href="http://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td></tr><tr><td>25</td><td><a href="http://www.runoob.com/java/java-string-length.html" target="_blank" rel="noopener">int length()</a>返回此字符串的长度。</td></tr><tr><td>26</td><td><a href="http://www.runoob.com/java/java-string-matches.html" target="_blank" rel="noopener">boolean matches(String regex)</a>告知此字符串是否匹配给定的正则表达式。</td></tr><tr><td>27</td><td><a href="http://www.runoob.com/java/java-string-regionmatches.html" target="_blank" rel="noopener">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a>测试两个字符串区域是否相等。</td></tr><tr><td>28</td><td><a href="http://www.runoob.com/java/java-string-regionmatches.html" target="_blank" rel="noopener">boolean regionMatches(int toffset, String other, int ooffset, int len)</a>测试两个字符串区域是否相等。</td></tr><tr><td>29</td><td><a href="http://www.runoob.com/java/java-string-replace.html" target="_blank" rel="noopener">String replace(char oldChar, char newChar)</a>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td></tr><tr><td>30</td><td><a href="http://www.runoob.com/java/java-string-replaceall.html" target="_blank" rel="noopener">String replaceAll(String regex, String replacement)</a>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td></tr><tr><td>31</td><td><a href="http://www.runoob.com/java/java-string-replacefirst.html" target="_blank" rel="noopener">String replaceFirst(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td></tr><tr><td>32</td><td><a href="http://www.runoob.com/java/java-string-split.html" target="_blank" rel="noopener">String[] split(String regex)</a>根据给定正则表达式的匹配拆分此字符串。</td></tr><tr><td>33</td><td><a href="http://www.runoob.com/java/java-string-split.html" target="_blank" rel="noopener">String[] split(String regex, int limit)</a>根据匹配给定的正则表达式来拆分此字符串。</td></tr><tr><td>34</td><td><a href="http://www.runoob.com/java/java-string-startswith.html" target="_blank" rel="noopener">boolean startsWith(String prefix)</a>测试此字符串是否以指定的前缀开始。</td></tr><tr><td>35</td><td><a href="http://www.runoob.com/java/java-string-startswith.html" target="_blank" rel="noopener">boolean startsWith(String prefix, int toffset)</a>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td></tr><tr><td>36</td><td><a href="http://www.runoob.com/java/java-string-subsequence.html" target="_blank" rel="noopener">CharSequence subSequence(int beginIndex, int endIndex)</a> 返回一个新的字符序列，它是此序列的一个子序列。</td></tr><tr><td>37</td><td><a href="http://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">String substring(int beginIndex)</a>返回一个新的字符串，它是此字符串的一个子字符串。</td></tr><tr><td>38</td><td><a href="http://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">String substring(int beginIndex, int endIndex)</a>返回一个新字符串，它是此字符串的一个子字符串。</td></tr><tr><td>39</td><td><a href="http://www.runoob.com/java/java-string-tochararray.html" target="_blank" rel="noopener">char[] toCharArray()</a>将此字符串转换为一个新的字符数组。</td></tr><tr><td>40</td><td><a href="http://www.runoob.com/java/java-string-tolowercase.html" target="_blank" rel="noopener">String toLowerCase()</a>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td>41</td><td><a href="http://www.runoob.com/java/java-string-tolowercase.html" target="_blank" rel="noopener">String toLowerCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td></tr><tr><td>42</td><td><a href="http://www.runoob.com/java/java-string-tostring.html" target="_blank" rel="noopener">String toString()</a> 返回此对象本身（它已经是一个字符串！）。</td></tr><tr><td>43</td><td><a href="http://www.runoob.com/java/java-string-touppercase.html" target="_blank" rel="noopener">String toUpperCase()</a>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td>44</td><td><a href="http://www.runoob.com/java/java-string-touppercase.html" target="_blank" rel="noopener">String toUpperCase(Locale locale)</a>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td></tr><tr><td>45</td><td><a href="http://www.runoob.com/java/java-string-trim.html" target="_blank" rel="noopener">String trim()</a>返回字符串的副本，忽略前导空白和尾部空白。</td></tr><tr><td>46</td><td><a href="http://www.runoob.com/java/java-string-valueof.html" target="_blank" rel="noopener">static String valueOf(primitive data type x)</a>返回给定data type类型x参数的字符串表示形式。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制语句</title>
      <link href="/2017/03/13/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2017/03/13/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果<br>有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现<br>我们要完成的功能。</p><a id="more"></a><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//顺序执行，根据编写的顺序，从上到下运行</span></span><br><span class="line">    System.out.println(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><h5 id="if"><a href="#if" class="headerlink" title="if"></a><strong><em>if</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">if</span>(关系表达式)｛</span><br><span class="line">语句体;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先判断关系表达式看其结果是true还是false</li><li>如果是true就执行语句体</li><li>如果是false就不执行语句体</li></ol><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1t8cccttj30e60bjmy1.jpg" alt="1547126916761"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始"</span>);</span><br><span class="line"><span class="comment">// 定义两个变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//变量使用if判断</span></span><br><span class="line">    <span class="keyword">if</span> (a == b)&#123;</span><br><span class="line">    System.out.println(<span class="string">"a等于b"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == c)&#123;</span><br><span class="line">    System.out.println(<span class="string">"a等于c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h5 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a><strong><em>if…else</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">if</span>(关系表达式) &#123;</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先判断关系表达式看其结果是true还是false</li><li>如果是true就执行语句体1</li><li>如果是false就执行语句体2</li></ol><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1tbqggjsj30ex0bs75c.jpg" alt="1547127135299"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断给定的数据是奇数还是偶数</span></span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"a是偶数"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"a是奇数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="if-else-if…else"><a href="#if-else-if…else" class="headerlink" title="if..else if…else"></a><strong><em>if..else if…else</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>) &#123;</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先判断关系表达式1看其结果是true还是false</li><li>如果是true就执行语句体1</li><li>如果是false就继续判断关系表达式2看其结果是true还是false</li><li>如果是true就执行语句体2</li><li>如果是false就继续判断关系表达式…看其结果是true还是false</li><li>…</li><li>如果没有任何关系表达式为true，就执行语句体n+1。</li></ol><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1tfe3m3fj30o80kvacs.jpg" alt="1547127344405"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x和y的关系满足如下：</span></span><br><span class="line">    <span class="comment">// x&gt;=3 y = 2x + 1;</span></span><br><span class="line">    <span class="comment">//‐1&lt;=x&lt;3 y = 2x;</span></span><br><span class="line">    <span class="comment">// x&lt;=‐1 y = 2x – 1;</span></span><br><span class="line">    <span class="comment">// 根据给定的x的值，计算出y的值并输出。</span></span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;= <span class="number">3</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= ‐<span class="number">1</span> &amp;&amp; x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    y = <span class="number">2</span> * x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    y = <span class="number">2</span> * x ‐ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"y的值是："</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h4><h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a><strong><em>switch</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>首先计算出表达式的值</li><li>其次，和case依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结束。</li><li>最后，如果所有的case都和表达式的值不匹配，就会执行default语句体部分，然后程序结束掉。</li></ol><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1tja6zvgj30n30bwabv.jpg" alt="1547127571620"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义变量，判断是星期几</span></span><br><span class="line">    <span class="keyword">int</span> weekday = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//switch语句实现选择</span></span><br><span class="line">    <span class="keyword">switch</span>(weekday) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"星期一"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"星期二"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"你输入的数字有误"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。</span></span><br></pre></td></tr></table></figure><h5 id="case的穿透性"><a href="#case的穿透性" class="headerlink" title="case的穿透性"></a><strong><em>case的穿透性</em></strong></h5><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运<br>行，直到遇到break，或者整体switch结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"执行case0"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            System.out.println(<span class="string">"执行case5"</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        System.out.println(<span class="string">"执行case10"</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"执行default"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会break，直接</span></span><br><span class="line"><span class="comment">//运行完整体switch。</span></span><br><span class="line"><span class="comment">//由于case存在穿透性，因此初学者在编写switch语句时，必须要写上break。</span></span><br></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><h5 id="for"><a href="#for" class="headerlink" title="for"></a><strong><em>for</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">for</span>(初始化表达式<span class="number">1</span>; 布尔表达式<span class="number">2</span>; 步进表达式<span class="number">3</span>)&#123;</span><br><span class="line">循环体<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程<br>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>①负责完成循环变量初始化<br>②负责判断是否满足循环条件，不满足则跳出循环<br>③具体执行的语句<br>④循环后，循环条件所涉及变量的变化情况</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1tr686vwj30d40czdh7.jpg" alt="1547128025686"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//控制台输出4次HelloWorld，不使用循环</span></span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">    System.out.println(<span class="string">"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐"</span>);</span><br><span class="line">    <span class="comment">//用循环改进，循环3次</span></span><br><span class="line">    <span class="comment">//定义变量从0开始，循环条件为&lt;3</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">3</span>; x++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"HelloWorld"</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg 2 使用循环，计算1-100之间的偶数和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.定义一个初始化变量,记录累加求和,初始值为0</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2.利用for循环获取1‐100之间的数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//3.判断获取的数组是奇数还是偶数</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//4.如果是偶数就累加求和</span></span><br><span class="line">        sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.循环结束之后,打印累加结果</span></span><br><span class="line">    System.out.println(<span class="string">"sum:"</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="while"><a href="#while" class="headerlink" title="while"></a><strong><em>while</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程<br>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>①负责完成循环变量初始化。<br>②负责判断是否满足循环条件，不满足则跳出循环。<br>③具体执行的语句。<br>④循环后，循环变量的变化情况。</p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1tvj7v9uj30an0bvgmn.jpg" alt="1547128275709"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg 1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//while循环实现打印10次HelloWorld</span></span><br><span class="line">    <span class="comment">//定义初始化变量</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//循环条件&lt;=10</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        <span class="comment">//步进</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//eg 2 while循环计算1-100之间的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用while循环实现</span></span><br><span class="line">    <span class="comment">//定义一个变量,记录累加求和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义初始化表达式</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//使用while循环让初始化表达式的值变化</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    <span class="comment">//累加求和</span></span><br><span class="line">    sum += i ;</span><br><span class="line">        <span class="comment">//步进表达式改变变量的值</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印求和的变量</span></span><br><span class="line">    System.out.println(<span class="string">"1‐100的和是："</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a><strong><em>do…while</em></strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure><p>执行流程<br>执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。<br>①负责完成循环变量初始化。<br>②负责判断是否满足循环条件，不满足则跳出循环。<br>③具体执行的语句<br>④循环后，循环变量的变化情况</p><p><img src="http://wx4.sinaimg.cn/mw690/0077hIeDly1fz1tzr10a0j30dr0fbwgi.jpg" alt="1547128484462"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(x&lt;=<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do…while循环的特点：无条件执行一次循环体，即使我们将循环条件直接写成false，也依然会循环一次。这样的<br>循环具有一定的风险性，因此初学者不建议使用do…while循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"无条件执行一次"</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环语句的区别</p><p>for 和 while 的小区别：<br>1.控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继<br>续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消<br>失，能够提高内存的使用效率。<br>2.在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</p><h4 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h4><p>死循环：也就是循环中的条件永远为true，死循环的是永不结束的循环。例如：while(true){}。欲想结束死循环就要用到跳出语句。</p><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p>所谓嵌套循环，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总<br>共的循环次数=外循环次数*内循环次数<br>嵌套循环格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①; 循环条件②; 步进表达式⑦) &#123;</span><br><span class="line">    <span class="keyword">for</span>(初始化表达式③; 循环条件④; 步进表达式⑥) &#123;</span><br><span class="line">    执行语句⑤;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套循环执行流程：<br>执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥<br>外循环一次，内循环多次。<br>比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。</p><h3 id="跳出语句"><a href="#跳出语句" class="headerlink" title="跳出语句"></a>跳出语句</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>使用场景：终止switch或者循环</p><ul><li>在选择结构switch语句中</li><li>在循环语句中</li><li>离开使用场景的存在是没有意义的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//需求:打印完两次HelloWorld之后结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>使用场景：结束本次循环，继续下一次的循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//需求:不打印第三次HelloWorld</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 流程控制语句 </tag>
            
            <tag> 循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java入门简介以及环境搭建(JDK安装&amp;配置环境变量)</title>
      <link href="/2017/03/13/Java%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(JDK%E5%AE%89%E8%A3%85&amp;%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)/"/>
      <url>/2017/03/13/Java%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA(JDK%E5%AE%89%E8%A3%85&amp;%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F)/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>Java语言概述：Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p><a id="more"></a><h3 id="Java语言发展历史"><a href="#Java语言发展历史" class="headerlink" title="Java语言发展历史"></a>Java语言发展历史</h3><ol><li>1995年Sun公司发布Java1.0版本</li><li>1997年发布Java 1.1版本</li><li>1998年发布Java 1.2版本</li><li>2000年发布Java 1.3版本</li><li>2002年发布Java 1.4版本</li><li>2004年发布Java 1.5版本</li><li>2006年发布Java 1.6版本</li><li>2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 1.7版本</li><li>2014年发布Java 1.8版本</li><li>2017年发布Java 9.0版本</li></ol><p>Java语言主要应用在互联网程序的开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服<br>务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。</p><h3 id="Java语言开发环境搭建"><a href="#Java语言开发环境搭建" class="headerlink" title="Java语言开发环境搭建"></a>Java语言开发环境搭建</h3><h4 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a><strong>JVM虚拟机</strong></h4><p>学习开发环境之前，首先来了解一下JVM虚拟机。</p><p>Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在JVM 之上。<br>跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系<br>统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM<br>运行在操作系统上。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1s2z0el7j30i5070q5d.jpg" alt="JVM"></p><p>JDK与JRE：</p><p>JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含JVM 和运行时所需要的核心类库 。<br>JDK (Java Development Kit)：是Java程序开发工具包，包含JRE 和开发人员使用的工具。<br>我们想要运行一个已有的Java程序，那么只需安装JRE 即可。<br>我们想要开发一个全新的Java程序，那么必须安装JDK 。</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1s6a99rxj30n10f3n7o.jpg" alt="null"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//三者关系</span><br><span class="line">JDK &gt; JRE &gt; JVM</span><br></pre></td></tr></table></figure><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a><strong>安装JDK</strong></h4><p>安装的文件不要有中文和空格！（本文以jdk9为例）</p><p><img src="http://wx3.sinaimg.cn/mw690/0077hIeDly1fz1salpnqaj30e40awwgq.jpg" alt="1547124983933"></p><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1sg2ha0ij30e70amtc8.jpg" alt="1547125280563"></p><p><img src="http://wx2.sinaimg.cn/mw690/0077hIeDly1fz1sgrivh2j30e40awjto.jpg" alt="1547125346294"></p><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1sifa9ldj30ea0asmzm.jpg" alt="1547125427398"></p><p><img src="http://wx1.sinaimg.cn/mw690/0077hIeDly1fz1sjyjhi8j30ed0astay.jpg" alt="1547125479599"></p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h4><p>安装完JDK之后还需要配置系统的环境变量，因为程序开发中，需要用到JDK提高的工具包。</p><p>环境变量的配置直接从百度爬过来的。附上连接，我就不一一截图了。</p><p>[<a href="https://jingyan.baidu.com/article/d45ad148ba5ab169552b80d3.html]" target="_blank" rel="noopener">https://jingyan.baidu.com/article/d45ad148ba5ab169552b80d3.html]</a>:</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK安装 </tag>
            
            <tag> 环境变量配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/2017/03/09/hello-hexo/"/>
      <url>/2017/03/09/hello-hexo/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jan 27 2019 18:14:02 GMT+0800 (GMT+08:00) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
